// Generated by dts-bundle-generator v9.5.1

export declare let UNDEFINED: symbol;
export declare class IfNotDefined {
	readonly value: any;
	constructor(value: any);
}
export declare function ifNotDefined(value: any): IfNotDefined;
export type MetaArg<TYPE> = TYPE | undefined | typeof UNDEFINED | IfNotDefined;
export declare class MetadataLibrary {
	KEY: symbol;
	protected findParentMeta(target: any, property?: string): any;
	set(KEY: symbol, value: any, t: any, p?: string): void;
	add(KEY: symbol, value: any, t: any, p?: string): void;
	obj(KEY: symbol, key: symbol | string, value: any, t: any, p?: string): void;
	get<T = any>(KEY: symbol, t: any, p?: string): T | undefined;
	protected getMetaObject(t: any, p?: string): any;
}
/** Represents a middleware function.
 * @template T - The type of the state object.
 * @param state - The state object to pass through the middleware.
 * @param next - The next middleware function in the pipeline.
 * @returns A promise that resolves after executing the middleware.
 */
export type MiddlewareFn<STATE = any, RESULT = any> = (state: STATE, next: () => Promise<RESULT>) => Promise<RESULT>;
/** Represents a middleware object.
 * @template T - The type of the state object.
 */
export type Middleware<STATE = any, RESULT = any> = any & {
	handle: MiddlewareFn<STATE, RESULT>;
};
/** Executes a pipeline of middlewares in a specific order.
 * @param {STATE} state - The state object to pass through the pipeline.
 * @param {Array<MiddlewareFn<STATE> | Middleware<STATE>} middlewares - The middlewares to execute in the pipeline.
 * @returns {Promise<any>} A promise that resolves after executing all middlewares in the pipeline.
 * @template STATE - The type of the state object.
 * @template RES - The type of the result object.
 */
export declare function pipeline<STATE = any, RESULT = any>(state: STATE, ...middlewares: Array<MiddlewareFn<STATE, RESULT> | Middleware<STATE, RESULT>>): Promise<any>;
/** Represents a pipeline of middlewares.
 * @template STATE - The type of the state object.
 * @template RES - The type of the result object.
 * */
export declare class Pipeline<STATE = any, RESULT = any> {
	/** The middlewares to execute in the pipeline. */
	private readonly middlewares;
	/** Initializes a new instance of the Pipeline class.
	 * @param {Array<MiddlewareFn<STATE> | Middleware<STATE>} middlewares - The middlewares to execute in the pipeline.
	 */
	constructor(...middlewares: Array<MiddlewareFn<STATE, RESULT> | Middleware<STATE, RESULT>>);
	/** Executes the pipeline with the specified state object.
	 * @param {STATE} state - The state object to pass through the pipeline.
	 * @returns {Promise<RES>} A promise that resolves with the result of the pipeline execution.
	 */
	run(state: STATE): Promise<RESULT>;
}
export declare function getAllMethods(obj: any): string[];
export declare function toKebabCase(input: string): string;
export declare function toSnakeCase(input: string): string;
export declare enum HttpStatusCode {
	Continue = 100,
	SwitchingProtocols = 101,
	Processing = 102,
	EarlyHints = 103,
	OK = 200,
	Created = 201,
	Accepted = 202,
	NonAuthoritativeInformation = 203,
	NoContent = 204,
	ResetContent = 205,
	PartialContent = 206,
	MultiStatus = 207,
	AlreadyReported = 208,
	IMUsed = 226,
	MultipleChoices = 300,
	MovedPermanently = 301,
	Found = 302,
	SeeOther = 303,
	NotModified = 304,
	UseProxy = 305,
	TemporaryRedirect = 307,
	PermanentRedirect = 308,
	BadRequest = 400,
	Unauthorized = 401,
	PaymentRequired = 402,
	Forbidden = 403,
	NotFound = 404,
	MethodNotAllowed = 405,
	NotAcceptable = 406,
	ProxyAuthenticationRequired = 407,
	RequestTimeout = 408,
	Conflict = 409,
	Gone = 410,
	LengthRequired = 411,
	PreconditionFailed = 412,
	PayloadTooLarge = 413,
	URITooLong = 414,
	UnsupportedMediaType = 415,
	RangeNotSatisfiable = 416,
	ExpectationFailed = 417,
	ImATeapot = 418,// Just for fun! Defined in RFC 2324
	MisdirectedRequest = 421,
	UnprocessableEntity = 422,
	Locked = 423,
	FailedDependency = 424,
	TooEarly = 425,
	UpgradeRequired = 426,
	PreconditionRequired = 428,
	TooManyRequests = 429,
	RequestHeaderFieldsTooLarge = 431,
	UnavailableForLegalReasons = 451,
	InternalServerError = 500,
	NotImplemented = 501,
	BadGateway = 502,
	ServiceUnavailable = 503,
	GatewayTimeout = 504,
	HTTPVersionNotSupported = 505,
	VariantAlsoNegotiates = 506,
	InsufficientStorage = 507,
	LoopDetected = 508,
	NotExtended = 510,
	NetworkAuthenticationRequired = 511
}
export declare function getHttpStatusName(code: HttpStatusCode): string;
export type ErrorData = {
	message?: string;
	details?: Record<string, any>;
	httpResponseCode: number;
	silent: boolean;
};
/**
 * Represents an extended error with additional properties such as error code, details, HTTP response code, and whether it should be silent.
 */
export declare class ResponseException extends Error {
	readonly message: string;
	readonly code: string;
	readonly details?: Record<string, any> | undefined;
	readonly httpResponseCode: number;
	readonly silent: boolean;
	/**
	 * Creates an instance of ExtendedError.
	 *
	 * @param {string} message - The error message.
	 * @param {string} code - The error code.
	 * @param {Record<string, any>} [details] - Additional details about the error.
	 * @param {number} [httpResponseCode=500] - The HTTP response code associated with the error.
	 * @param {boolean} [silent=false] - Whether the error should be silent (i.e., not logged or reported).
	 */
	constructor(message: string, code: string, details?: Record<string, any> | undefined, httpResponseCode?: number, silent?: boolean);
	/**
	 * Creates an error data object with optional properties including error message, details, HTTP response code, and whether the error should be silent.
	 *
	 * @param {string} [message] - The error message.
	 * @param {Record<string, any>} [details] - Additional details about the error.
	 * @param {number} [httpResponseCode=500] - The HTTP response code associated with the error.
	 * @param {boolean} [silent=false] - Whether the error should be silent (i.e., not logged or reported).
	 * @returns {ErrorData} An error data object containing the specified properties.
	 */
	static create(message?: string, details?: Record<string, any>, httpResponseCode?: number, silent?: boolean): ErrorData;
	/**
	 * Preprocesses an error tree, converting all functions within the tree into error-generating functions
	 * that create instances of ExtendedError with predefined error codes based on their names and positions in the tree.
	 *
	 * @param {Record<string, any>} errors - The error tree to preprocess.
	 * @param {string} [prefix=""] - An optional prefix to prepend to all error codes generated from function names.
	 * @returns {void}
	 */
	static errorGroup(errors: Record<string, any>, prefix?: string): void;
}
/**
 * Alias for ResponseError::create()
 * Creates an error data object with optional properties including error message, details, HTTP response code, and whether the error should be silent.
 *
 * @param {string} [message] - The error message.
 * @param {Record<string, any>} [details] - Additional details about the error.
 * @param {number} [httpResponseCode=500] - The HTTP response code associated with the error.
 * @param {boolean} [silent=false] - Whether the error should be silent (i.e., not logged or reported).
 * @returns {ErrorData} An error data object containing the specified properties.
 */
export declare let err: typeof ResponseException.create;
/**
 * Alias for ResponseError::errorGroup()
 * Preprocesses an error tree, converting all functions within the tree into error-generating functions
 * that create instances of ExtendedError with predefined error codes based on their names and positions in the tree.
 *
 * @param {Record<string, any>} errors - The error tree to preprocess.
 * @param {string} [prefix=""] - An optional prefix to prepend to all error codes generated from function names.
 * @returns {void}
 */
export declare let errorGroup: typeof ResponseException.errorGroup;
export type ConstructorOf<CLASS> = new (...args: any[]) => CLASS;
export type MaybePromise<TYPE> = TYPE | Promise<TYPE>;
export type MaybeArray<TYPE> = TYPE | Array<TYPE>;
export type MaybeUndefined<TYPE> = TYPE | undefined;
export type MaybeNull<TYPE> = TYPE | null;
export type MaybeUnset<TYPE> = TYPE | null | undefined;
export type NonEmptyArray<T = any> = [
	T,
	...T[]
];
export type EmptyArray = [
];
export type NumericString = `${number}`;
export type Numeric = NumericString | number;
export type ToString<TYPE> = TYPE & string;
/**
 * A constructor type.
 * @template OBJECT_TYPE - The type of the object.
 */
export type T_Constructor<OBJECT_TYPE> = (new (...args: any[]) => OBJECT_TYPE);
/**
 * A class type.
 * @template OBJECT_TYPE - The type of the object.
 * @template CLASS - The type of the class.
 */
export type T_Class<OBJECT_TYPE, CLASS> = T_Constructor<OBJECT_TYPE> & CLASS;
export type OmittedObject<Values extends Record<string, any>, Fields extends Array<keyof Values>> = {
	[P in keyof Values as Exclude<P, Fields[number]>]: Values[P];
};
export type PickedObject<Values extends Record<string, any>, Fields extends Array<keyof Values>> = {
	[P in Fields[number]]: Values[P];
};
export type NonFunctionKeys<VALUES extends Record<string, any>> = {
	[P in keyof VALUES]: VALUES[P] extends (...args: any[]) => any ? never : P;
}[keyof VALUES];
export type ExcludeFunctions<VALUES extends Record<string, any>> = Partial<Pick<VALUES, NonFunctionKeys<VALUES>>>;
/**
 * Filters the fields of an object based on a provided list of field names.
 * @param values - The object containing the fields to be filtered.
 * @param fields - An array of field names to include in the filtered result.
 * @returns An object containing only the fields specified in the 'fields' array.
 */
export declare function pickFieldsIP<PICKED extends Array<keyof VALUES>, VALUES extends Record<string, any>>(values: VALUES, ...fields: PICKED): PickedObject<VALUES, PICKED>;
/**
 * Omits specified fields from an object.
 * @param values - The object containing the fields to be omitted.
 * @param fields - An array of field names to be omitted from the object.
 * @returns An object containing all fields except those specified in the 'fields' array.
 */
export declare function omitFieldsIP<REMOVED extends Array<keyof VALUES>, VALUES extends Record<string, any>>(values: VALUES, ...fields: REMOVED): OmittedObject<VALUES, REMOVED>;
/**
 * Filters the fields of an object based on a provided list of field names and returns a new object.
 * @param values - The object containing the fields to be filtered.
 * @param fields - An array of field names to include in the filtered result.
 * @returns A new object containing only the fields specified in the 'fields' array.
 */
export declare function pickFields<PICKED extends Array<keyof VALUES>, VALUES extends Record<string, any>>(values: VALUES, ...fields: PICKED): PickedObject<VALUES, PICKED>;
/**
 * Omits specified fields from an object and returns a new object.
 * @param values - The object containing the fields to be omitted.
 * @param fields - An array of field names to be omitted from the object.
 * @returns A new object containing all fields except those specified in the 'fields' array.
 */
export declare function omitFields<REMOVED extends Array<keyof VALUES>, VALUES extends Record<string, any>>(values: VALUES, ...fields: REMOVED): OmittedObject<VALUES, REMOVED>;
/**
 * Retrieves the first element of an array or returns undefined if the array is blank.
 * @param array - The array from which to retrieve the first element.
 * @returns The first element of the array, or undefined if the array is blank.
 */
export declare function firstOrUndefined<ARRAY extends Array<any>>(array: ARRAY): ARRAY[number];
/**
 * Generates a map from an array of items using a specified key.
 * @template T - The type of items.
 * @param items - An array of items.
 * @param key - The key to use for mapping.
 * @returns A map where the keys are IDs and the values are items.
 */
export declare function keyMap<T extends Record<string, any>>(items: Array<T>, key?: string): Record<number, T>;
export type FileSizeWithUnit = `${number}KB` | `${number}kb` | `${number}kB` | `${number}MB` | `${number}mb` | `${number}GB` | `${number}gb` | `${number}TB` | `${number}tb` | `${number}B` | `${number}b` | `${number}` | number;
/**
 * Converts a string representation of file size to bytes. If a numeric value is provided, it returns it as is.
 * @param {string | number} sizeWithUnit - The size string with optional unit (e.g., "14kb", "35mb") or a numeric value representing bytes.
 * @returns {number} The size in bytes.
 * @throws {Error} If the provided size string is in an invalid format or if an invalid unit is encountered.
 * @description
 * This function accepts a string representation of file size with optional unit (e.g., "14kb", "35mb") or a numeric value representing bytes.
 * It converts the size to bytes and returns the result.
 * If a numeric value is provided, it is returned as is.
 * If the size string is in an invalid format or if an invalid unit is encountered, it throws an error.
 * Supported units are "kb" (kilobytes), "mb" (megabytes), "gb" (gigabytes), and "tb" (terabytes).
 * The function is case-insensitive and accepts both lowercase and uppercase unit abbreviations.
 */
export declare function bytes(sizeWithUnit: FileSizeWithUnit): number;
export type GetPropertyDescriptor<T, R> = PropertyDescriptor & {
	get?: (this: T) => R;
};
/**
 * A decorator function that materializes a getter property into a value property after the first access.
 * @param target - The target object.
 * @param name - The name of the property.
 * @param descriptor - The property descriptor.
 */
export declare function MaterializeIt<T, R>(target: any, name: PropertyKey, descriptor: GetPropertyDescriptor<T, R>): void;
/**
 * Materializes the property if it is defined.
 *
 * @param target - The target object.
 * @param name - The name of the property.
 * @param descriptor - The property descriptor.
 */
export declare function MaterializeIfDefined<T, R>(target: any, name: PropertyKey, descriptor: PropertyDescriptor): void;
export type State<T = {}> = Record<string, any> & T;
/**
 * Represents an interface for a block in a process pipeline.
 * @template OPTIONS - The type of options for the block.
 */
export interface Block<OPTIONS extends string> {
	/**
	 * Prepends a segment to the block.
	 * @param {Function} segment - The segment function to prepend.
	 * @returns The updated block runner instance.
	 */
	prepend: (segment: Function) => Record<OPTIONS, BlockRunner<OPTIONS>>;
	/**
	 * Appends a segment to the block.
	 * @param {Function} segment - The segment function to append.
	 * @returns The updated block runner instance.
	 */
	append: (segment: Function) => Record<OPTIONS, BlockRunner<OPTIONS>>;
}
declare class BlockRunner<OPTIONS extends string> implements Block<OPTIONS> {
	#private;
	readonly pipeline: ProcessPipeline<OPTIONS>;
	constructor(pipeline: ProcessPipeline<OPTIONS>);
	/**
	 * Runs the block runner by executing segments in the specified order.
	 * @param {object | undefined} ctx - The context object.
	 * @param {State} state - The state object to pass through the block runner.
	 * @returns {Promise<void>} A promise that resolves after executing all segments.
	 */
	run(ctx: object | undefined, state: State): Promise<void>;
	/**
	 * Prepends a segment to the block runner.
	 * @param {Function} segment - The segment function to prepend.
	 * @returns {Record<OPTIONS, BlockRunner<OPTIONS>>} The updated block runner instance.
	 */
	prepend(segment: Function): Record<OPTIONS, BlockRunner<OPTIONS>>;
	/**
	 * Appends a segment to the block runner.
	 * @param {Function} segment - The segment function to append.
	 * @returns {Record<OPTIONS, BlockRunner<OPTIONS>>} The updated block runner instance.
	 */
	append(segment: Function): Record<OPTIONS, BlockRunner<OPTIONS>>;
}
/**
 * Represents a process pipeline for executing blocks of functions in a specific order.
 * @template OPTIONS - The type of options for the process pipeline.
 */
export declare class ProcessPipeline<OPTIONS extends string = string> {
	#private;
	private readonly names;
	/**
	 * Accessible blocks of the process pipeline.
	 * @type {Record<OPTIONS, Block<OPTIONS>>}
	 */
	readonly blocks: Record<OPTIONS, Block<OPTIONS>>;
	/**
	 * Initializes the ProcessPipeline with the provided names.
	 * @param {...OPTIONS} names - The names of the blocks in the process pipeline.
	 */
	constructor(...names: OPTIONS[]);
	/**
	 * Runs the process pipeline by executing blocks in the specified order.
	 * @param {object | undefined} ctx - The context object.
	 * @param {Record<string, any>} state - The state object to pass through the pipeline.
	 * @returns {Promise<Record<string, any>>} A promise that resolves to the final state after executing all blocks.
	 */
	run(ctx: object | undefined, state: Record<string, any>): Promise<Record<string, any>>;
	/**
	 * Sets up the process pipeline blocks with the provided functions.
	 * @param {Partial<Record<OPTIONS, [Function] | Function>>} blocks - The functions to set up for each block.
	 * @returns {this} The updated ProcessPipeline instance.
	 */
	setup(blocks: Partial<Record<OPTIONS, [
		Function
	] | Function>>): this;
}

export {};
