// Generated by dts-bundle-generator v9.5.1

import { Buffer } from 'buffer';
import { BinaryToTextEncoding } from 'crypto';
import jwt from 'jsonwebtoken';

export type KeyValue<T> = {
	key: string | number;
	value: T;
};
/**
 * Cache is an abstract class that provides caching functionality.
 *
 * @template T - The type of the cached items.
 */
declare abstract class Cache$1<T = any> {
	protected ttl: number;
	protected prefix?: string | undefined;
	protected constructor(ttl: number, prefix?: string | undefined);
	/**
	 * Returns a function that reads a cached item if available; otherwise, retrieves it using the provided handler and caches it.
	 * @param ttl - Optional time-to-live value for the cached item.
	 * @returns A function that reads and caches items.
	 */
	getReader(ttl?: number): (handler: () => any, key: string | number, ttl?: number) => Promise<any>;
	/**
	 * Returns a function that deletes an item from the cache by key.
	 * @returns A function that deletes items from the cache.
	 */
	getInvalidator(): (key: string | number) => Promise<void>;
	/**
	 * Reads a cached item by key or retrieves it using the provided handler and caches it.
	 * @param handler - The function to retrieve the item if not cached.
	 * @param key - The key of the item to read or retrieve.
	 * @param ttl - Optional time-to-live value for the cached item.
	 * @returns A Promise resolving to the retrieved item.
	 */
	read(handler: () => any, key: string | number, ttl?: number): Promise<any>;
	/**
	 * Generates a cache key based on the provided key(s) and prefix.
	 * @param keys - The key or array of keys to generate the cache key(s) from.
	 * @returns The generated cache key(s).
	 */
	key(keys: Array<string | number>): Array<string>;
	key(key: string | number): string;
	key(key: string | number | Array<string | number>): string | Array<string>;
	/**
	 * Abstract method to set item(s) in the cache with an optional TTL.
	 * @param item - The key-value pair or array of key-value pairs to set in the cache.
	 * @param ttl - Optional time-to-live value for the cached item(s).
	 * @returns A Promise indicating the success of the operation.
	 */
	abstract set(item: KeyValue<T>, ttl?: number): Promise<void>;
	abstract set(items: Array<KeyValue<T>>, ttl?: number): Promise<void>;
	/**
	 * Abstract method to get a cached item by key.
	 * @param key - The key of the item to retrieve from the cache.
	 * @returns A Promise resolving to the cached item or undefined.
	 */
	abstract get(key: string | number): Promise<T | undefined>;
	abstract get(keys: Array<string | number>): Promise<Array<T>>;
	/**
	 * Abstract method to delete an item from the cache by key.
	 * @param key - The key of the item to delete from the cache.
	 * @returns A Promise indicating the success of the operation.
	 */
	abstract del(key: string | number): Promise<void>;
	abstract del(keys: Array<string | number>): Promise<void>;
	/**
	 * Abstract method to clear all items from the cache.
	 * @returns A Promise indicating the success of the operation.
	 */
	abstract clear(): Promise<void>;
}
export declare class CacheWithNoCache<T = any> extends Cache$1<T> {
	constructor(ttl: number, prefix?: string);
	get(key: string | number): Promise<T | undefined>;
	get(keys: Array<string | number>): Promise<Array<T>>;
	set(item: KeyValue<T>, ttl?: number): Promise<void>;
	set(items: Array<KeyValue<T>>, ttl?: number): Promise<void>;
	del(keys: Array<string | number>): Promise<void>;
	del(key: string | number): Promise<void>;
	clear(): Promise<void>;
}
export declare let fse: {
	isExists: (path: string) => Promise<boolean>;
	isFile: (path: string) => Promise<boolean>;
	isDir: (path: string) => Promise<boolean>;
	isImage: (path: string) => boolean;
	stat: (path: string) => Promise<fs.Stats>;
	fileSize: (file: string) => Promise<number>;
	name: {
		findUnique: (inDir: string, name: string) => Promise<string>;
		sanitize: (name: string) => string;
	};
	path: {
		join: (args_0: string, ...args: string[]) => string;
		resolve: (args_0: string, ...args: string[]) => string;
	};
	mimeType: {
		map: Record<string, string>;
		lookup: (filename: string) => string;
	};
	rmEmptyParents: (dir: string) => Promise<void>;
	tmpFileCreatorFactory: (tmp: string) => TmpFileCreator;
};
export declare class TmpFile {
	file: string;
	get filename(): string;
	constructor(file: string);
	release(): Promise<void>;
}
export declare class TmpFileCreator {
	private path;
	constructor(path: string);
	get targetDir(): Promise<string>;
	createFromFile(file: File, removeOriginal?: boolean): Promise<TmpFile>;
	createFromBuffer(filename: string, buffer: Buffer): Promise<TmpFile>;
	createFromFilePath(file: string, removeOriginal?: boolean): Promise<TmpFile>;
}
export declare function hash(string: string, algorithm?: string, encoding?: BinaryToTextEncoding): Promise<string>;
export declare class Password {
	private readonly pepper;
	private algorithm;
	private encoding;
	constructor(pepper: Buffer, algorithm?: string, encoding?: BinaryToTextEncoding);
	hash(password: string): Promise<string>;
}
/** Wrapper class for encoding and decoding JSON Web Tokens. */
export declare class Jwt<T> {
	private readonly secret;
	private readonly expires?;
	private readonly algorithm;
	constructor(secret: string, expires?: string | undefined, algorithm?: jwt.Algorithm);
	decode(token: string | undefined): T | undefined;
	encode(payload: T, expires?: string | number): string;
	static getStringContent(token: string | undefined): string | undefined;
	static getContent(token: string | undefined): undefined;
}
export type Dimension = {
	width: number;
	height: number;
};
export type RGB = {
	r: number;
	g: number;
	b: number;
};
export type CropMode = "centre" | "top" | "left" | "bottom" | "right" | "entropy" | "attention" | "manual" | "face" | "box";
export type Point = {
	x: number;
	y: number;
};
export type Rect = Point & Dimension;
export type ImgInfo = {
	dim: Dimension;
	dominant: RGB;
	isAnimated: boolean;
	crop: CropMode;
	focus: {
		point: Point;
		area: Rect;
		face: null | Rect;
	};
};
export type CropParams = {
	width: number;
	height: number;
	density: undefined | number;
	mode: undefined | CropMode;
};
export interface ImgInterface {
	readonly file: string;
	getInfo(setFace: boolean): Promise<ImgInfo>;
	crop(output: string, cropParams: CropParams, imgInfo: ImgInfo): Promise<void>;
}

export {
	Cache$1 as Cache,
};

export {};
