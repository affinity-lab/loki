// Generated by dts-bundle-generator v9.5.1

import { InferSelectModel, Placeholder } from 'drizzle-orm';
import { MySqlColumn, MySqlTable, MySqlTableWithColumns, MySqlView } from 'drizzle-orm/mysql-core';
import { MySqlIntBuilderInitial } from 'drizzle-orm/mysql-core/columns/int';
import { MySqlSelectWithout } from 'drizzle-orm/mysql-core/query-builders/select.types';
import { MySql2Database } from 'drizzle-orm/mysql2';

export type ErrorData = {
	message?: string;
	details?: Record<string, any>;
	httpResponseCode: number;
	silent: boolean;
};
export type MaybePromise<TYPE> = TYPE | Promise<TYPE>;
export type MaybeArray<TYPE> = TYPE | Array<TYPE>;
export type MaybeUndefined<TYPE> = TYPE | undefined;
export type MaybeNull<TYPE> = TYPE | null;
export type MaybeUnset<TYPE> = TYPE | null | undefined;
export type NonEmptyArray<T = any> = [
	T,
	...T[]
];
export type NumericString = `${number}`;
/**
 * A constructor type.
 * @template OBJECT_TYPE - The type of the object.
 */
export type T_Constructor<OBJECT_TYPE> = (new (...args: any[]) => OBJECT_TYPE);
/**
 * A class type.
 * @template OBJECT_TYPE - The type of the object.
 * @template CLASS - The type of the class.
 */
export type T_Class<OBJECT_TYPE, CLASS> = T_Constructor<OBJECT_TYPE> & CLASS;
export type NonFunctionKeys<VALUES extends Record<string, any>> = {
	[P in keyof VALUES]: VALUES[P] extends (...args: any[]) => any ? never : P;
}[keyof VALUES];
export type ExcludeFunctions<VALUES extends Record<string, any>> = Partial<Pick<VALUES, NonFunctionKeys<VALUES>>>;
export type FileSizeWithUnit = `${number}KB` | `${number}kb` | `${number}kB` | `${number}MB` | `${number}mb` | `${number}GB` | `${number}gb` | `${number}TB` | `${number}tb` | `${number}B` | `${number}b` | `${number}` | number;
export type State<T = {}> = Record<string, any> & T;
/**
 * Represents an interface for a block in a process pipeline.
 * @template OPTIONS - The type of options for the block.
 */
export interface Block<OPTIONS extends string> {
	/**
	 * Prepends a segment to the block.
	 * @param {Function} segment - The segment function to prepend.
	 * @returns The updated block runner instance.
	 */
	prepend: (segment: Function) => Record<OPTIONS, BlockRunner<OPTIONS>>;
	/**
	 * Appends a segment to the block.
	 * @param {Function} segment - The segment function to append.
	 * @returns The updated block runner instance.
	 */
	append: (segment: Function) => Record<OPTIONS, BlockRunner<OPTIONS>>;
}
declare class BlockRunner<OPTIONS extends string> implements Block<OPTIONS> {
	#private;
	readonly pipeline: ProcessPipeline<OPTIONS>;
	constructor(pipeline: ProcessPipeline<OPTIONS>);
	/**
	 * Runs the block runner by executing segments in the specified order.
	 * @param {object | undefined} ctx - The context object.
	 * @param {State} state - The state object to pass through the block runner.
	 * @returns {Promise<void>} A promise that resolves after executing all segments.
	 */
	run(ctx: object | undefined, state: State): Promise<void>;
	/**
	 * Prepends a segment to the block runner.
	 * @param {Function} segment - The segment function to prepend.
	 * @returns {Record<OPTIONS, BlockRunner<OPTIONS>>} The updated block runner instance.
	 */
	prepend(segment: Function): Record<OPTIONS, BlockRunner<OPTIONS>>;
	/**
	 * Appends a segment to the block runner.
	 * @param {Function} segment - The segment function to append.
	 * @returns {Record<OPTIONS, BlockRunner<OPTIONS>>} The updated block runner instance.
	 */
	append(segment: Function): Record<OPTIONS, BlockRunner<OPTIONS>>;
}
declare class ProcessPipeline<OPTIONS extends string = string> {
	#private;
	private readonly names;
	/**
	 * Accessible blocks of the process pipeline.
	 * @type {Record<OPTIONS, Block<OPTIONS>>}
	 */
	readonly blocks: Record<OPTIONS, Block<OPTIONS>>;
	/**
	 * Initializes the ProcessPipeline with the provided names.
	 * @param {...OPTIONS} names - The names of the blocks in the process pipeline.
	 */
	constructor(...names: OPTIONS[]);
	/**
	 * Runs the process pipeline by executing blocks in the specified order.
	 * @param {object | undefined} ctx - The context object.
	 * @param {Record<string, any>} state - The state object to pass through the pipeline.
	 * @returns {Promise<Record<string, any>>} A promise that resolves to the final state after executing all blocks.
	 */
	run(ctx: object | undefined, state: Record<string, any>): Promise<Record<string, any>>;
	/**
	 * Sets up the process pipeline blocks with the provided functions.
	 * @param {Partial<Record<OPTIONS, [Function] | Function>>} blocks - The functions to set up for each block.
	 * @returns {this} The updated ProcessPipeline instance.
	 */
	setup(blocks: Partial<Record<OPTIONS, [
		Function
	] | Function>>): this;
}
export type WithIdOptional<TYPE = {}> = {
	id: MaybeNull<number>;
} & TYPE;
export type WithId<TYPE = {}> = {
	id: number;
} & TYPE;
export type WithIds<TYPE = {}> = {
	ids: Array<number>;
} & TYPE;
/**
 * The data transfer object type.
 * @template SCHEMA - The type of the database schema representing the entity's view.
 */
export type Dto<SCHEMA extends MySqlTable> = WithIdOptional<InferSelectModel<SCHEMA>>;
export type ViewDto<SCHEMA extends MySqlTable | MySqlView<any, any, any>> = WithIdOptional<SCHEMA extends MySqlTable ? InferSelectModel<SCHEMA> : MySqlView<any, any, any>>;
/**
 * The fields of an entity that can be used.
 * @template SCHEMA - The type of the database schema representing the entity's view.
 */
export type EntityFields<SCHEMA extends MySqlTable> = Partial<WithIdOptional<Omit<InferSelectModel<SCHEMA>, "id">>>;
/**
 * Class representing a storm view entity.
 */
export declare abstract class ViewEntity {
	static repository: ViewEntityRepositoryInterface;
	get $repository(): ViewEntityRepositoryInterface<any, any, any, any>;
	id: MaybeNull<number>;
	get $id(): number;
	constructor();
	private static get exportFields();
	/**
	 * Exports the entity to a plain object for exporting.
	 * @returns A plain object representation of the entity.
	 */
	$export(): Record<string, any>;
	/**
	 * Picks specified fields from export.
	 * @param fields
	 */
	$pick(...fields: string[]): Record<string, any>;
	/**
	 * Omits specified fields from export.
	 * @param fields
	 */
	$omit(...fields: string[]): Record<string, any>;
	/**
	 * Returns a JSON representation of the entity.
	 * @returns A JSON representation of the entity.
	 */
	toJSON(): Record<string, any>;
	/**
	 * Returns a string representation of the entity.
	 * @returns A string representation of the entity.
	 */
	toString(): string;
}
export interface ViewEntityRepositoryInterface<SCHEMA extends MySqlTable<any> | MySqlView<any, any, any> = any, ITEM extends ViewEntity = any, ENTITY extends T_Class<ITEM, typeof ViewEntity> = any, DTO extends ViewDto<SCHEMA> = any> {
	readonly db: MySql2Database<any>;
	readonly schema: SCHEMA;
	readonly entity: ENTITY;
	fields: string[];
	pipelines: {
		getAll: ProcessPipeline<"prepare" | "action" | "finalize">;
		getOne: ProcessPipeline<"prepare" | "action" | "finalize">;
		getArray: ProcessPipeline<"prepare" | "action" | "finalize">;
	};
	instantiate: {
		all: (dtoSet: Array<DTO>) => Promise<Array<ITEM>>;
		one: (dto: (DTO | undefined)) => Promise<undefined | ITEM>;
		first: (dtoSet: Array<DTO>) => Promise<MaybeUndefined<ITEM>>;
	};
	addPlugin(plugin: (repository: ViewEntityRepositoryInterface) => any): this;
	getRawDTO(id: MaybeUnset<number>): Promise<MaybeUndefined<DTO>>;
	get(): Promise<Array<ITEM>>;
	get(ids: Array<number>): Promise<Array<ITEM>>;
	get(id: MaybeUnset<number>): Promise<ITEM | undefined>;
	create(): Promise<ITEM>;
	reload(item: any): Promise<void>;
}
export interface EntityRepositoryInterface<SCHEMA extends MySqlTableWithColumns<any> = any, ITEM extends Entity = any, ENTITY extends T_Class<ITEM, typeof Entity> = any, DTO extends Dto<SCHEMA> = any> extends ViewEntityRepositoryInterface<SCHEMA, ITEM, ENTITY> {
	pipelines: {
		getAll: ProcessPipeline<"prepare" | "action" | "finalize">;
		getOne: ProcessPipeline<"prepare" | "action" | "finalize">;
		getArray: ProcessPipeline<"prepare" | "action" | "finalize">;
		insert: ProcessPipeline<"prepare" | "action" | "finalize">;
		update: ProcessPipeline<"prepare" | "action" | "finalize">;
		delete: ProcessPipeline<"prepare" | "action" | "finalize">;
		overwrite: ProcessPipeline<"prepare" | "action" | "finalize">;
	};
	instantiate: {
		all: (dtoSet: Array<DTO>) => Promise<Array<ITEM>>;
		one: (dto: (DTO | undefined)) => Promise<undefined | ITEM>;
		first: (dtoSet: Array<DTO>) => Promise<MaybeUndefined<ITEM>>;
	};
	addPlugin(plugin: (repository: EntityRepositoryInterface) => any): this;
	save(item: ITEM | undefined): Promise<any>;
	update(item: ITEM | undefined): Promise<any>;
	insert(item: ITEM | undefined): Promise<any>;
	overwrite(item: ITEM | undefined, values: Record<string, any>, reload?: boolean): Promise<any>;
	delete(item: ITEM | undefined): Promise<any>;
	create(importData?: Dto<MySqlTable>): Promise<ITEM>;
}
/**
 * Class representing a storm entity.
 */
export declare abstract class Entity extends ViewEntity {
	static repository: EntityRepositoryInterface;
	get $repository(): EntityRepositoryInterface<any, any, any, any>;
	private static get importFields();
	/**
	 * Imports data into the entity.
	 * @param importData record of the properties to copy onto the entity.
	 * @param onlyDecoratedProperties the properties doesn't have to be decorated if this is false (default true)
	 */
	$import<DATA extends {
		[P in keyof ExcludeFunctions<this>]: ExcludeFunctions<this>[P];
	}>(importData: DATA, onlyDecoratedProperties?: boolean): this;
	/**
	 * Saves the entity to the database.
	 * @param saveData: properties of Entity
	 * @param onlyDecoratedProperties sets if @Import decorator is required or not for the properties you save this way, false by default
	 */
	$save<DATA extends {
		[P in keyof ExcludeFunctions<this>]: ExcludeFunctions<this>[P];
	}>(saveData?: DATA, onlyDecoratedProperties?: boolean): Promise<any>;
	/**
	 * Deletes the entity from the database.
	 */
	$delete(): Promise<any>;
	/**
	 * Overwrites the entity with the provided data, without validation.
	 * @param data
	 */
	$overwrite<KEY extends keyof this>(data: Record<KEY, typeof Entity[KEY]>): Promise<any>;
}
/**
 * A generic repository class for handling Read operations for storm entity in a MySQL database view.
 * @template SCHEMA - The type of the database schema representing the entity's view.
 * @template ITEM - The type of the entity class.
 */
export declare class ViewEntityRepository<SCHEMA extends MySqlTable<any> | MySqlView<any, any, any>, ITEM extends ViewEntity, ENTITY extends T_Class<ITEM, typeof ViewEntity> = T_Class<ITEM, typeof ViewEntity>, DTO extends ViewDto<SCHEMA> = ViewDto<SCHEMA>> implements ViewEntityRepositoryInterface<SCHEMA, ITEM, ENTITY, DTO> {
	readonly db: MySql2Database<any>;
	readonly schema: SCHEMA;
	readonly entity: ENTITY;
	readonly fields: string[];
	pipelines: {
		getOne: ProcessPipeline<"prepare" | "action" | "finalize">;
		getArray: ProcessPipeline<"prepare" | "action" | "finalize">;
		getAll: ProcessPipeline<"prepare" | "action" | "finalize">;
	};
	instantiate: {
		/**
		 * Instantiates multiple items from an array of DTOs.
		 * @param dtoSet
		 * @returns An array of instantiated items.
		 */
		all: (dtoSet: Array<DTO>) => Promise<Array<ITEM>>;
		/**
		 * Instantiates the first item from an array of DTOs.
		 * @param dtoSet
		 * @returns The instantiated item, or undefined if the array is blank.
		 */
		first: (dtoSet: Array<DTO>) => Promise<MaybeUndefined<ITEM>>;
		/**
		 * Instantiates an item from a DTO.
		 * @param dto
		 * @returns The instantiated item, or undefined if the DTO is undefined.
		 */
		one: (dto: DTO | undefined) => Promise<ITEM | undefined>;
	};
	protected exec: {
		getOne: (id: number) => Promise<any>;
		getArray: (ids: Array<number>) => Promise<any>;
		getAll: () => Promise<any>;
	};
	constructor(db: MySql2Database<any>, schema: SCHEMA, entity: ENTITY);
	addPlugin(plugin: (repository: ViewEntityRepositoryInterface) => any): this;
	protected initialize(): void;
	protected get stmt_all(): (args: undefined) => Promise<DTO[]>;
	protected get stmt_get_array(): (args: {
		ids: Array<number>;
	}) => Promise<DTO[]>;
	protected get stmt_get(): (args: {
		id: number;
	}) => Promise<MaybeUndefined<DTO>>;
	protected pipelineFactory(): {
		getOne: ProcessPipeline<"prepare" | "action" | "finalize">;
		getArray: ProcessPipeline<"prepare" | "action" | "finalize">;
		getAll: ProcessPipeline<"prepare" | "action" | "finalize">;
	};
	protected pipelineExecFactory(): {
		getOne: (id: number) => Promise<any>;
		getArray: (ids: Array<number>) => Promise<any>;
		getAll: () => Promise<any>;
	};
	protected instantiateFactory(): {
		/**
		 * Instantiates multiple items from an array of DTOs.
		 * @param dtoSet
		 * @returns An array of instantiated items.
		 */
		all: (dtoSet: Array<DTO>) => Promise<Array<ITEM>>;
		/**
		 * Instantiates the first item from an array of DTOs.
		 * @param dtoSet
		 * @returns The instantiated item, or undefined if the array is blank.
		 */
		first: (dtoSet: Array<DTO>) => Promise<MaybeUndefined<ITEM>>;
		/**
		 * Instantiates an item from a DTO.
		 * @param dto
		 * @returns The instantiated item, or undefined if the DTO is undefined.
		 */
		one: (dto: DTO | undefined) => Promise<ITEM | undefined>;
	};
	/**
	 * Prepares the item DTO. This is a hook method intended for subclass overrides.
	 * @param dto The DTO to prepare.
	 */
	protected transformItemDTO(dto: DTO): MaybePromise<void>;
	/**
	 * Applies the DTO to the item.
	 * @param item The item to apply the DTO to.
	 * @param dto The data transfer object (DTO) containing the data to be applied to the item.
	 */
	protected applyItemDTO(item: ITEM, dto: DTO): Promise<void>;
	/**
	 * Retrieves the raw data of an entity by its ID.
	 * @param id - The ID of the entity.
	 * @returns A promise resolving to the raw data of the entity, or undefined if not found.
	 */
	getRawDTO(id: MaybeUnset<number>): Promise<MaybeUndefined<DTO>>;
	/**
	 * Retrieves all items
	 * @returns A promise resolving to all items.
	 */
	get(): Promise<Array<ITEM>>;
	/**
	 * Retrieves one or multiple items by their IDs.
	 * @param ids
	 * @returns A promise resolving to one or multiple items, or undefined if not found.
	 */
	get(ids: Array<number>): Promise<Array<ITEM>>;
	/**
	 * Retrieves one item by the provided ID.
	 * @param id
	 * @returns A promise resolving to the item, or undefined if not found.
	 */
	get(id: MaybeUnset<number>): Promise<ITEM | undefined>;
	/**
	 * Creates a new item.
	 * @param importData - initial data to import into the new item.
	 * @returns A promise that resolves to the new item.
	 */
	create(): Promise<ITEM>;
	/**
	 * Reloads an item from the database.
	 * @param item - The item to reload.
	 * @returns A promise that resolves once the item has been reloaded.
	 */
	reload(item: ITEM): Promise<void>;
}
/**
 * A generic repository class for handling CRUD operations for storm entity in a MySQL database.
 * @template SCHEMA - The type of the database schema representing the entity's table.
 * @template ITEM - The type of the entity class.
 **/
export declare class EntityRepository<SCHEMA extends MySqlTableWithColumns<any>, ITEM extends Entity, ENTITY extends T_Class<ITEM, typeof Entity> = T_Class<ITEM, typeof Entity>, DTO extends Dto<SCHEMA> = Dto<SCHEMA>> extends ViewEntityRepository<SCHEMA, ITEM, ENTITY, ViewDto<SCHEMA>> implements EntityRepositoryInterface<SCHEMA, ITEM, ENTITY> {
	protected pipelineFactory(): {
		insert: ProcessPipeline<"prepare" | "action" | "finalize">;
		update: ProcessPipeline<"prepare" | "action" | "finalize">;
		delete: ProcessPipeline<"prepare" | "action" | "finalize">;
		overwrite: ProcessPipeline<"prepare" | "action" | "finalize">;
		getOne: ProcessPipeline<"prepare" | "action" | "finalize">;
		getArray: ProcessPipeline<"prepare" | "action" | "finalize">;
		getAll: ProcessPipeline<"prepare" | "action" | "finalize">;
	};
	protected pipelineExecFactory(): {
		delete: (item: ITEM) => Promise<Record<string, any>>;
		insert: (item: ITEM) => Promise<ITEM>;
		update: (item: ITEM) => Promise<ITEM>;
		overwrite: (item: ITEM, values: Record<string, any>, reload?: boolean) => Promise<ITEM>;
		getOne: (id: number) => Promise<any>;
		getArray: (ids: Array<number>) => Promise<any>;
		getAll: () => Promise<any>;
	};
	readonly pipelines: {
		insert: ProcessPipeline<"prepare" | "action" | "finalize">;
		update: ProcessPipeline<"prepare" | "action" | "finalize">;
		delete: ProcessPipeline<"prepare" | "action" | "finalize">;
		overwrite: ProcessPipeline<"prepare" | "action" | "finalize">;
		getOne: ProcessPipeline<"prepare" | "action" | "finalize">;
		getArray: ProcessPipeline<"prepare" | "action" | "finalize">;
		getAll: ProcessPipeline<"prepare" | "action" | "finalize">;
	};
	protected readonly exec: {
		delete: (item: ITEM) => Promise<Record<string, any>>;
		insert: (item: ITEM) => Promise<ITEM>;
		update: (item: ITEM) => Promise<ITEM>;
		overwrite: (item: ITEM, values: Record<string, any>, reload?: boolean) => Promise<ITEM>;
		getOne: (id: number) => Promise<any>;
		getArray: (ids: Array<number>) => Promise<any>;
		getAll: () => Promise<any>;
	};
	constructor(db: MySql2Database<any>, schema: SCHEMA, entity: ENTITY);
	protected initialize(): void;
	addPlugin(plugin: (repository: EntityRepositoryInterface) => any): this;
	/**
	 * Retrieves the data transfer object (DTO) from the item.
	 * @param item The item from which to retrieve the DTO.
	 * @returns The DTO representing the item.
	 */
	protected extractItemDTO(item: ITEM): DTO;
	protected getInsertDTO(item: ITEM): Promise<DTO>;
	protected getUpdateDTO(item: ITEM): Promise<DTO>;
	/**
	 * Prepares the DTO for saving by filtering and omitting specified fields.
	 * @param dto The DTO to prepare for saving.
	 */
	protected transformSaveDTO(dto: DTO): MaybePromise<void>;
	/**
	 * Prepares the DTO for insertion by filtering and omitting specified fields.
	 * @param dto The DTO to prepare for insertion.
	 */
	protected transformInsertDTO(dto: DTO): MaybePromise<void>;
	/**
	 * Prepares the DTO for updating by filtering and omitting specified fields.
	 * @param dto The DTO to prepare for updating.
	 */
	protected transformUpdateDTO(dto: DTO): MaybePromise<void>;
	/**
	 * Prepares the item DTO. This is a hook method intended for subclass overrides.
	 * @param dto The DTO to prepare.
	 */
	protected transformItemDTO(dto: Dto<SCHEMA>): MaybePromise<void>;
	/**
	 * Applies the DTO to the item.
	 * @param item The item to apply the DTO to.
	 * @param dto The data transfer object (DTO) containing the data to be applied to the item.
	 */
	protected applyItemDTO(item: ITEM, dto: Dto<SCHEMA>): Promise<void>;
	/**
	 * Creates a new item.
	 * @param importData - initial data to import into the new item.
	 * @param onlyDecoratedProperties the properties doesn't have to be decorated if this is false (default true)
	 * @returns A promise that resolves to the new item.
	 */
	create(importData?: Record<string, any>, onlyDecoratedProperties?: boolean): Promise<ITEM>;
	/**
	 * Saves an item by either updating it if it already exists or inserting it if it's new.
	 * @param item - The item to save.
	 * @returns A promise that resolves once the save operation is completed.
	 */
	save(item: ITEM | undefined): Promise<ITEM | undefined>;
	/**
	 * Updates an existing item.
	 * @param item - The item to update.
	 * @returns A promise that resolves once the update operation is completed.
	 */
	update(item: ITEM | undefined): Promise<ITEM | undefined>;
	/**
	 * Inserts a new item.
	 * @param item - The item to insert.
	 * @returns A promise that resolves once the insert operation is completed.
	 */
	insert(item: ITEM | undefined): Promise<ITEM | undefined>;
	/**
	 * Overwrites an item with new values.
	 * @param item - The item to overwrite.
	 * @param values - The new values to overwrite the item with.
	 * @param [reload=true] - Whether to reload the item after overwriting.
	 * @returns A promise that resolves once the overwrite operation is completed.
	 */
	overwrite(item: ITEM | undefined, values: Record<string, any>, reload?: boolean): Promise<ITEM | undefined>;
	/**
	 * Deletes an item.
	 * @param item - The item to delete.
	 * @returns A promise that resolves once the delete operation is completed.
	 */
	delete(item: ITEM | undefined): Promise<Record<string, any> | undefined>;
}
/**
 * Creates an SQL expression for checking if a column's value is in a list of IDs.
 * @param col - The column to check.
 * @param ids - The list of IDs.
 * @returns An SQL expression.
 */
export declare function In(col: MySqlColumn, ids: string): import("drizzle-orm").SQL<unknown>;
/**
 * Executes a MySQL SELECT statement asynchronously, applying multiple processing functions to the result.
 * @template ARGS - Type of the arguments accepted by the MySQL SELECT statement.
 * @template RES - Type of the result returned by the processing functions.
 * @param stmt - The MySQL SELECT statement object.
 * @param processes - Processing functions to be applied to the result sequentially.
 * @returns A promise that resolves with a function accepting arguments of type ARGS and returning a result of type RES.
 */
export declare function stmt<RES>(stmt: MySqlSelectWithout<any, any, any>, ...processes: ((res: any) => any)[]): () => Promise<RES>;
export declare function stmt<ARGS, RES>(stmt: MySqlSelectWithout<any, any, any>, ...processes: ((res: any) => any)[]): (args: ARGS) => Promise<RES>;
/**
 * Set of utility functions to generate SQL LIKE query patterns for string matching.
 */
export declare const likeString: {
	/**
	 * Generates a SQL LIKE query pattern to match strings that start with the specified search string.
	 * @param search - The string to match within.
	 * @returns A SQL LIKE query pattern.
	 */
	startsWith: (search: string) => string;
	/**
	 * Generates a SQL LIKE query pattern to match strings that end with the specified search string.
	 * @param search - The string to match within.
	 * @returns A SQL LIKE query pattern.
	 */
	endWith: (search: string) => string;
	/**
	 * Generates a SQL LIKE query pattern to match strings that contain the specified search string.
	 * @param search - The string to match within.
	 * @returns A SQL LIKE query pattern.
	 */
	contains: (search: string) => string;
};
/**
 * Retrieves a single item from a repository by a specified field.
 * @param repo
 * @param fieldName
 * @returns A function that retrieves the previous DTO of an item.
 */
export declare function getByFactory<T extends string | number, R extends ViewEntity>(repo: ViewEntityRepositoryInterface, fieldName: Extract<keyof R, T>): (search: T) => Promise<R | undefined>;
export declare function getAllByFactory<T extends string | number, R extends ViewEntity>(repo: ViewEntityRepositoryInterface, fieldName: Extract<keyof R, T>): (search: T) => Promise<Array<R>>;
/**
 * Retrieves the previous data transfer object (DTO) of an item.
 * Use it in pipeline functions to access the previous DTO of the item.
 * @param state
 * @param repository
 */
export declare function prevDto(state: State, repository: EntityRepositoryInterface): Promise<any>;
export declare function Export(t: any, p: string): void;
export declare namespace Export {
	var read: (t: any) => string[];
}
export declare function Import(t: any, p: string): void;
export declare namespace Import {
	var read: (t: any) => string[];
}
export declare let stormSchemaHelpers: {
	id: () => import("drizzle-orm").IsPrimaryKey<import("drizzle-orm").NotNull<import("drizzle-orm").IsAutoincrement<import("drizzle-orm").HasDefault<import("drizzle-orm/mysql-core").MySqlIntBuilderInitial<"id">>>>>;
	reference: (name: string, field: () => MySqlColumn, nullable?: boolean) => import("drizzle-orm/mysql-core").MySqlIntBuilderInitial<string>;
};
export declare let stormSqlHelpers: {
	like: (col: MySqlColumn, key: string) => import("drizzle-orm").SQL<unknown>;
	in: (col: MySqlColumn, array: Array<any> | Placeholder) => import("drizzle-orm").SQL<unknown>;
};
export declare const entityError: {
	itemNotFound: (repository: string, id: number | undefined | null) => ErrorData;
	itemNotExists: () => ErrorData;
	duplicateEntry: (args: any) => ErrorData;
};
export type AttachmentObject = {
	name: string;
	size: number;
	id: string;
	metadata: Record<string, any>;
};
export type AttachmentObjects = Array<AttachmentObject>;
export type AttachmentRecord = {
	id: number;
	name: string;
	itemId: number;
	data: string;
};
export type ITmpFile = {
	file: string;
	filename: string;
	release: () => void | Promise<void>;
};
export type CollectionOptions = {
	limit?: {
		size?: number | NumericString | FileSizeWithUnit;
		count?: number | NumericString;
	};
	mime?: string | Array<string>;
	ext?: string | Array<string>;
};
export type Rules = {
	limit: {
		size: number;
		count: number;
	};
	mime: undefined | Array<string>;
	ext: undefined | Array<string>;
};
export type KeyValue<T> = {
	key: string | number;
	value: T;
};
declare abstract class Cache$1<T = any> {
	protected ttl: number;
	protected prefix?: string | undefined;
	protected constructor(ttl: number, prefix?: string | undefined);
	/**
	 * Returns a function that reads a cached item if available; otherwise, retrieves it using the provided handler and caches it.
	 * @param ttl - Optional time-to-live value for the cached item.
	 * @returns A function that reads and caches items.
	 */
	getReader(ttl?: number): (handler: () => any, key: string | number, ttl?: number) => Promise<any>;
	/**
	 * Returns a function that deletes an item from the cache by key.
	 * @returns A function that deletes items from the cache.
	 */
	getInvalidator(): (key: string | number) => Promise<void>;
	/**
	 * Reads a cached item by key or retrieves it using the provided handler and caches it.
	 * @param handler - The function to retrieve the item if not cached.
	 * @param key - The key of the item to read or retrieve.
	 * @param ttl - Optional time-to-live value for the cached item.
	 * @returns A Promise resolving to the retrieved item.
	 */
	read(handler: () => any, key: string | number, ttl?: number): Promise<any>;
	/**
	 * Generates a cache key based on the provided key(s) and prefix.
	 * @param keys - The key or array of keys to generate the cache key(s) from.
	 * @returns The generated cache key(s).
	 */
	key(keys: Array<string | number>): Array<string>;
	key(key: string | number): string;
	key(key: string | number | Array<string | number>): string | Array<string>;
	/**
	 * Abstract method to set item(s) in the cache with an optional TTL.
	 * @param item - The key-value pair or array of key-value pairs to set in the cache.
	 * @param ttl - Optional time-to-live value for the cached item(s).
	 * @returns A Promise indicating the success of the operation.
	 */
	abstract set(item: KeyValue<T>, ttl?: number): Promise<void>;
	abstract set(items: Array<KeyValue<T>>, ttl?: number): Promise<void>;
	/**
	 * Abstract method to get a cached item by key.
	 * @param key - The key of the item to retrieve from the cache.
	 * @returns A Promise resolving to the cached item or undefined.
	 */
	abstract get(key: string | number): Promise<T | undefined>;
	abstract get(keys: Array<string | number>): Promise<Array<T>>;
	/**
	 * Abstract method to delete an item from the cache by key.
	 * @param key - The key of the item to delete from the cache.
	 * @returns A Promise indicating the success of the operation.
	 */
	abstract del(key: string | number): Promise<void>;
	abstract del(keys: Array<string | number>): Promise<void>;
	/**
	 * Abstract method to clear all items from the cache.
	 * @returns A Promise indicating the success of the operation.
	 */
	abstract clear(): Promise<void>;
}
export type Dimension = {
	width: number;
	height: number;
};
export type RGB = {
	r: number;
	g: number;
	b: number;
};
export type CropMode = "centre" | "top" | "left" | "bottom" | "right" | "entropy" | "attention" | "manual" | "face" | "box";
export type Point = {
	x: number;
	y: number;
};
export type Rect = Point & Dimension;
export type ImgInfo = {
	dim: Dimension;
	dominant: RGB;
	isAnimated: boolean;
	crop: CropMode;
	focus: {
		point: Point;
		area: Rect;
		face: null | Rect;
	};
};
export type CropParams = {
	width: number;
	height: number;
	density: undefined | number;
	mode: undefined | CropMode;
};
export interface ImgInterface {
	readonly file: string;
	getInfo(setFace: boolean): Promise<ImgInfo>;
	crop(output: string, cropParams: CropParams, imgInfo: ImgInfo): Promise<void>;
}
export type GroupDefinition = {
	storage: Storage$1;
	group: string;
	entityRepository: EntityRepositoryInterface;
};
export type Collections = Record<string, Collection>;
declare class Storage$1 {
	readonly path: string;
	readonly db: MySql2Database<any>;
	readonly schema: MySqlTable;
	readonly cache?: Cache$1 | undefined;
	readonly cleanup?: ((name: string, id: number, file: string) => Promise<void>) | undefined;
	constructor(path: string, db: MySql2Database<any>, schema: MySqlTable, cache?: Cache$1 | undefined, cleanup?: ((name: string, id: number, file: string) => Promise<void>) | undefined);
	collections: Collections;
	groups: Record<string, {
		collections: Collections;
		repository: EntityRepositoryInterface;
	}>;
	/**
	 * Add a collection to the storage
	 * @param collection
	 */
	addCollection(collection: any): void;
	/**
	 * Get a collection from the storage
	 * @param name
	 * @param entityRepository
	 */
	getGroupDefinition(name: string, entityRepository: EntityRepositoryInterface): GroupDefinition;
	private get stmt_get();
	private get stmt_all();
	private get stmt_del();
	getPath(name: string, id: number): string;
	protected getCacheKey(name: string, id: number): string;
	/**
	 * Get all attachments for a given name and id
	 * @param name
	 * @param id
	 * @param res
	 */
	get(name: string, id: number, res?: {
		found?: "db" | "cache" | false;
	}): Promise<AttachmentObjects>;
	protected getIndexOfAttachments(name: string, id: number, filename: string, fail?: boolean): Promise<{
		attachments: AttachmentObjects;
		index: number;
	}>;
	/**
	 * Delete all attachments for a given id
	 * @param repository
	 * @param id
	 */
	destroy(repository: EntityRepositoryInterface, id: number): Promise<void>;
	protected destroyFiles(name: string, id: number): Promise<void>;
	protected updateRecord(name: string, id: number, attachments: AttachmentObjects): Promise<void>;
	/**
	 * Add an attachment to the storage
	 * @param name
	 * @param id
	 * @param file
	 * @param metadata
	 */
	add(name: string, id: number, file: ITmpFile, metadata: Record<string, any>): Promise<void>;
	/**
	 * Delete an attachment from the storage
	 * @param name
	 * @param id
	 * @param filename
	 */
	delete(name: string, id: number, filename: string): Promise<void>;
	/**
	 * Set the position of an attachment
	 * @param name
	 * @param id
	 * @param filename
	 * @param position
	 */
	setPosition(name: string, id: number, filename: string, position: number): Promise<void>;
	/**
	 * Update the metadata of an attachment
	 * @param name
	 * @param id
	 * @param filename
	 * @param metadata
	 */
	updateMetadata(name: string, id: number, filename: string, metadata: Record<string, any>): Promise<void>;
	/**
	 * Rename an attachment
	 * @param name
	 * @param id
	 * @param filename
	 * @param newName
	 */
	rename(name: string, id: number, filename: string, newName: string): Promise<void>;
	plugin(): (repository: EntityRepositoryInterface) => void;
}
export declare class CollectionHandler<METADATA extends Record<string, any>> extends Array<Attachment<METADATA>> {
	#private;
	protected loaded: boolean;
	/**
	 * Get the entity owning the collection
	 */
	get entity(): WithIdOptional<Record<string, any>>;
	/**
	 * Get the id of the entity owning the collection
	 */
	get id(): number;
	/**
	 * Get the collection
	 */
	get collection(): Collection<METADATA>;
	/**
	 * Get the storage of the collection
	 */
	get storage(): Storage$1;
	constructor(collection: Collection<METADATA>, entity: WithIdOptional<Record<string, any>>);
	push(...args: any[]): never;
	unshift(...args: any[]): never;
	pop(): never;
	shift(): never;
	/**
	 * Load the collection
	 */
	load(): Promise<this>;
	/**
	 * Add a file to the collection
	 * @param file
	 */
	add(file: ITmpFile): Promise<void>;
	toJSON(): {
		collection: string;
		id: number;
		files: Array<{
			metadata: Record<string, any>;
			name: string;
			id: string;
			size: number;
		}> | null;
		rules: Record<string, any>;
	};
	/**
	 * Get the first file in the collection
	 */
	first(): Attachment<METADATA> | undefined;
	/**
	 * Get the last file in the collection
	 */
	last(): Attachment<METADATA> | undefined;
	/**
	 * Get a file by name
	 * @param filename
	 */
	findFile(filename: string): Attachment<METADATA> | undefined;
	/**
	 * Get files by a glob pattern
	 * @param glob
	 */
	findFiles(glob: string): Array<Attachment<METADATA>>;
}
export declare abstract class Collection<METADATA extends Record<string, any> = {}> {
	readonly name: string;
	readonly groupDefinition: {
		storage: Storage$1;
		group: string;
		entityRepository: EntityRepositoryInterface;
	};
	readonly entityRepository: EntityRepositoryInterface;
	readonly group: string;
	private readonly _storage;
	/**
	 * The storage of the collection
	 */
	get storage(): Storage$1;
	getPath(entityId: number): string;
	/**
	 * The rules for the collection
	 */
	readonly rules: Rules;
	constructor(name: string, groupDefinition: {
		storage: Storage$1;
		group: string;
		entityRepository: EntityRepositoryInterface;
	}, rules: CollectionOptions);
	/**
	 * Get a collection handler
	 * @param entity
	 */
	handler(entity: WithIdOptional<Record<string, any>>): CollectionHandler<METADATA> | undefined;
	protected updateMetadata(id: number, filename: string, metadata: Partial<METADATA>): Promise<void>;
	protected prepareFile(file: ITmpFile): Promise<{
		file: ITmpFile;
		metadata: Record<string, any>;
	}>;
	/**
	 * Prepare the file for storage
	 * @param collectionHandler
	 * @param file
	 */
	prepare(collectionHandler: CollectionHandler<METADATA>, file: ITmpFile): Promise<{
		file: ITmpFile;
		metadata: Record<string, any>;
	}>;
	/**
	 * Hook for when an attachment is removed
	 */
	onDelete(): Promise<void>;
	/**
	 * Hook for when an attachment is modified
	 */
	onModify(): Promise<void>;
	/**
	 * Get attachments for an entity
	 * @param id
	 */
	get(id: number): Promise<Array<Attachment<METADATA>>>;
}
export declare class Attachment<METADATA extends Record<string, any>> implements AttachmentObject {
	#private;
	/**
	 * The metadata of the attachment
	 */
	get metadata(): METADATA;
	/**
	 * The file size of the attachment
	 */
	get size(): number;
	/**
	 * The id of the attachment
	 */
	get id(): string;
	/**
	 * The filename of the attachment
	 */
	get name(): string;
	/**
	 * The collection of the attachment
	 */
	get collection(): Collection<METADATA>;
	/**
	 * The entity id of the attachment
	 */
	get entityId(): number;
	/**
	 * returns the path to the attachment
	 * */
	get path(): string;
	base64(): Promise<string>;
	dataUrl(): Promise<string>;
	constructor(attachmentObject: AttachmentObject, collection: Collection<METADATA>, entityId: number);
	toJSON(): {
		metadata: METADATA;
		name: string;
		id: string;
		size: number;
	};
	/**
	 * Save the metadata of the attachment
	 */
	saveMetaData(): Promise<void>;
	/**
	 * Set the position of the attachment
	 * @param position
	 */
	setPositions(position: number): Promise<void>;
	/**
	 * Delete the attachment
	 */
	delete(): Promise<void>;
	/**
	 * Rename the attachment
	 * @param name
	 */
	rename(name: string): Promise<void>;
}
export declare const storageError: {
	ownerNotExists: (name: string, id: number) => ErrorData;
	fileTooLarge: (name: string, id: number, filename: string, sizeLimit: number) => ErrorData;
	extensionNotAllowed: (name: string, id: number, filename: string, allowedExtensions: string | Array<string>) => ErrorData;
	tooManyFiles: (name: string, id: number, filename: string, limit: number) => ErrorData;
	attachedFileNotFound: (name: string, id: number, filename: string) => ErrorData;
};
export declare let stormStorageSchemaHelpers: {
	storageSchemaFactory: (name?: string) => import("drizzle-orm/mysql-core").MySqlTableWithColumns<{
		name: string;
		schema: undefined;
		columns: {
			id: import("drizzle-orm/mysql-core").MySqlColumn<{
				name: "id";
				tableName: string;
				dataType: "number";
				columnType: "MySqlSerial";
				data: number;
				driverParam: number;
				notNull: true;
				hasDefault: true;
				isPrimaryKey: true;
				isAutoincrement: true;
				hasRuntimeDefault: false;
				enumValues: undefined;
				baseColumn: never;
				generated: undefined;
			}, object>;
			name: import("drizzle-orm/mysql-core").MySqlColumn<{
				name: "name";
				tableName: string;
				dataType: "string";
				columnType: "MySqlVarChar";
				data: string;
				driverParam: string | number;
				notNull: true;
				hasDefault: false;
				isPrimaryKey: false;
				isAutoincrement: false;
				hasRuntimeDefault: false;
				enumValues: [
					string,
					...string[]
				];
				baseColumn: never;
				generated: undefined;
			}, object>;
			itemId: import("drizzle-orm/mysql-core").MySqlColumn<{
				name: "itemId";
				tableName: string;
				dataType: "number";
				columnType: "MySqlInt";
				data: number;
				driverParam: string | number;
				notNull: true;
				hasDefault: false;
				isPrimaryKey: false;
				isAutoincrement: false;
				hasRuntimeDefault: false;
				enumValues: undefined;
				baseColumn: never;
				generated: undefined;
			}, object>;
			data: import("drizzle-orm/mysql-core").MySqlColumn<{
				name: "data";
				tableName: string;
				dataType: "json";
				columnType: "MySqlJson";
				data: unknown;
				driverParam: string;
				notNull: false;
				hasDefault: true;
				isPrimaryKey: false;
				isAutoincrement: false;
				hasRuntimeDefault: false;
				enumValues: undefined;
				baseColumn: never;
				generated: undefined;
			}, object>;
		};
		dialect: "mysql";
	}>;
};
/**
 * Storage plugin
 * @param repository
 * @param storage
 */
export declare function storagePlugin(repository: EntityRepositoryInterface, storage: Storage$1): void;
export type ImageAttachmentMetadata = ImgInfo;
/**
 * Collection for image attachments
 */
export declare class ImageCollection extends Collection<ImageAttachmentMetadata> {
	private defaultCropMode;
	private imgFactory;
	private faceDetect;
	constructor(name: string, groupDefinition: {
		storage: Storage$1;
		group: string;
		entityRepository: EntityRepositoryInterface;
	}, rules: CollectionOptions, defaultCropMode: CropMode | undefined, imgFactory: (file: string) => ImgInterface, faceDetect?: boolean);
	protected prepareFile(file: ITmpFile): Promise<{
		file: ITmpFile;
		metadata: ImageAttachmentMetadata;
	}>;
}
export declare class ResultCache {
	readonly cache: Cache$1;
	constructor(cache: Cache$1);
	set(res: Record<string, any> | Array<Record<string, any>>): Promise<any[] | Record<string, any>>;
	get get(): {
		(key: string | number): Promise<any>;
		(keys: Array<string | number>): Promise<any[]>;
	};
	get del(): {
		(key: string | number): Promise<void>;
		(keys: Array<string | number>): Promise<void>;
	};
	get setter(): (res: Record<string, any> | Array<Record<string, any>>) => Promise<any[] | Record<string, any>>;
}
export declare class ResultCacheWithMaps extends ResultCache {
	readonly cache: Cache$1;
	readonly mapCache: Cache$1;
	readonly mappedFields: NonEmptyArray<string>;
	constructor(cache: Cache$1, mapCache: Cache$1, mappedFields: NonEmptyArray<string>);
	set(res: Record<string, any> | Array<Record<string, any>>): Promise<any[] | Record<string, any>>;
}
export declare function cachePlugin(resultCache: ResultCache): (repository: EntityRepositoryInterface) => void;
/**
 * Returns a function that will get an item by a field name and cache the result.
 * @param repo
 * @param fieldName
 * @param resultCache
 * @param mapCache
 */
export declare function cachedGetByFactory<T extends string | number, R extends ViewEntity>(repo: ViewEntityRepositoryInterface, fieldName: Extract<keyof R, T>, resultCache: ResultCacheWithMaps): (search: T) => Promise<R | undefined>;
export declare class SequenceManager {
	private repo;
	private sequenceField;
	private parentField;
	constructor(repo: EntityRepositoryInterface, sequenceField: string, parentField: string);
	protected max(parent: string | number): Promise<number>;
	protected next(parent: string | number): Promise<number>;
	move(entity: Entity, nextEntity: Entity): Promise<void>;
	move(entity: Entity, parentId: number | string): Promise<void>;
}
export type Usage = {
	repo: EntityRepositoryInterface;
	field: string;
};
export declare class TagEntity extends Entity {
	name: string;
}
export declare class TagRepository<SCHEMA extends MySqlTable, ITEM extends TagEntity, DTO extends Dto<SCHEMA> & {
	name: string;
} = Dto<SCHEMA> & {
	name: string;
}, ENTITY extends T_Class<ITEM, typeof TagEntity> = T_Class<ITEM, typeof TagEntity>> extends EntityRepository<SCHEMA, ITEM> {
	protected usages: Array<Usage>;
	protected initialize(addPipelines?: boolean): void;
	protected get stmt_getByName(): (args: {
		names: Array<string>;
	}) => Promise<ITEM[]>;
	/**
	 * Get tags by name
	 * @param names
	 */
	getByName(names: Array<string>): Promise<Array<ITEM>>;
	getByName(name: string): Promise<ITEM | undefined>;
	/**
	 * Rename the tag
	 * @param oldName
	 * @param newName
	 */
	rename(oldName: string, newName: string): Promise<void>;
	/**
	 * Delete a tag from all usages
	 * @param name
	 */
	deleteInUsages(name: string): Promise<void>;
	/**
	 * Add a usage to the tag
	 * @param usage
	 */
	protected addUsage(usage: MaybeArray<Usage>): void;
	/**
	 * Rename the tag
	 * @param dto
	 * @param prevDto
	 */
	protected selfRename(dto: DTO, prevDto: DTO): Promise<void>;
	/**
	 * Update the tag
	 * @param repository
	 * @param dto
	 * @param prevDto
	 */
	protected updateTag(repository: EntityRepositoryInterface, dto: DTO | {}, prevDto: DTO): Promise<void>;
	/**
	 * Normalize the tag values
	 * @param repository
	 * @param dto
	 */
	protected prepare(repository: EntityRepositoryInterface, dto: Record<string, any>): void;
	protected changes(repository: EntityRepositoryInterface, dto: Record<string, any>, prevDto: Record<string, any>): {
		prev: Array<string>;
		curr: Array<string>;
	};
	protected deleteTag(names: Array<string>): Promise<void>;
	protected deleteItems(items: Array<ITEM>): Promise<void>;
	protected addTag(names: Array<string>): Promise<void>;
	protected doRename(oldName: string, newName: string): Promise<void>;
	plugin(field: string): (repository: EntityRepositoryInterface) => void;
}
export type GroupUsage = {
	repo: EntityRepositoryInterface;
	field: string;
	groupField: string;
	mode?: "JSON" | "LIST";
};
export declare class GroupTagEntity extends TagEntity {
	groupId: number | string;
}
export declare class GroupTagRepository<SCHEMA extends MySqlTable, ITEM extends GroupTagEntity, DTO extends Dto<SCHEMA> & {
	name: string;
} = Dto<SCHEMA> & {
	name: string;
}, ENTITY extends T_Class<ITEM, typeof GroupTagEntity> = T_Class<ITEM, typeof GroupTagEntity>> extends TagRepository<SCHEMA, ITEM> {
	readonly db: MySql2Database<any>;
	readonly schema: SCHEMA;
	readonly entity: ENTITY;
	protected usages: Array<GroupUsage>;
	constructor(db: MySql2Database<any>, schema: SCHEMA, entity: ENTITY);
	protected initialize(): void;
	protected get stmt_groupGetByName(): (args: {
		names: Array<string>;
		groupId: number | string;
	}) => Promise<ITEM[]>;
	protected get stmt_getByGroup(): (args: {
		groupId: number | string;
	}) => Promise<ITEM[]>;
	/***
	 * returns all tags to a group
	 * @param groupId group's identifier
	 */
	getToGroup(groupId: number): Promise<ITEM[]>;
	/**
	 * Get tags by name and groupId
	 * @param names
	 * @param groupId
	 */
	getByName(names: Array<string>, groupId?: number | string): Promise<Array<ITEM>>;
	getByName(name: string, groupId?: number | string): Promise<ITEM | undefined>;
	/**
	 * Delete a tag from all usages, called when a tag is deleted manually
	 * @param name
	 * @param groupId
	 */
	deleteInUsages(name: string, groupId?: number | string): Promise<void>;
	/**
	 * Rename a tag
	 * @param oldName
	 * @param newName
	 * @param groupId
	 */
	rename(oldName: string, newName: string, groupId?: number | string): Promise<void>;
	/***
	 * Called by the tag's pipeline, checks for changes, adds and deletes the tags according to them.
	 * @param repository changed entity's repository
	 * @param item changed entity
	 * @param prevDto changed entity's previous state
	 * @param fieldName name of the tag field
	 */
	protected updateTag<ITEM extends Entity, FIELD_NAME extends keyof ITEM & string>(repository: EntityRepositoryInterface, item: ITEM, prevDto: Record<string, any>, fieldName?: FIELD_NAME): Promise<void>;
	/***
	 * creates 2 arrays of strings, one for the current tags on the changed entity, and one for the tags before the change.
	 * @param repository changed entity's repository
	 * @param item changed entity
	 * @param prevDto changed entity's previous state
	 * @protected
	 */
	protected changes(repository: EntityRepositoryInterface, item: Record<string, any>, prevDto: Record<string, any>): {
		prev: Array<string>;
		curr: Array<string>;
	};
	/***
	 * update pipeline calls this (manual name update)
	 * @param dto tag's dto
	 * @param prevDto tag's prevDto
	 */
	selfRename(dto: Record<string, any>, prevDto: Record<string, any>): Promise<void>;
	/***
	 * Called by updateTag, checks if any item needs to be added.
	 * @param names all tag names that was added to the entity
	 * @param groupId
	 */
	protected addTag(names: Array<string>, groupId?: number | string): Promise<void>;
	/***
	 * Called by updateTag, checks if any item needs to be deleted.
	 * @param names all tag names that was removed from the entity
	 * @param groupId
	 */
	protected deleteTag(names: Array<string>, groupId?: number | string): Promise<void>;
	/***
	 * Runs when a tag is removed from an entity's usage. It checks if the tag is associated with any other entities within the usages, and if not, the tag is deleted.
	 */
	protected deleteItems(items: Array<ITEM>, groupId?: number | string): Promise<void>;
	/***
	 * Updates the renamed tag in all of its usages.
	 */
	protected doRename(oldName: string, newName: string, groupId?: number | string): Promise<void>;
	protected prepare(repository: EntityRepositoryInterface, dto: Record<string, any>): void;
	plugin(field: string, groupField?: string, mode?: "JSON" | "LIST"): (repository: EntityRepositoryInterface) => void;
}
export declare const tagError: {
	itemNotFound: (repository: string) => ErrorData;
	groupId: (details?: any) => ErrorData;
	selfRename: () => ErrorData;
	groupPrepare: () => ErrorData;
};
export declare let stormTagSchemaHelpers: {
	tagTableFactory: (name: string, id: () => MySqlIntBuilderInitial<any>) => import("drizzle-orm/mysql-core").MySqlTableWithColumns<{
		name: string;
		schema: undefined;
		columns: {
			id: MySqlColumn<{
				name: any;
				tableName: string;
				dataType: "number";
				columnType: "MySqlInt";
				data: number;
				driverParam: string | number;
				notNull: false;
				hasDefault: false;
				isPrimaryKey: false;
				isAutoincrement: false;
				hasRuntimeDefault: false;
				enumValues: undefined;
				baseColumn: never;
				generated: undefined;
			}, object>;
			name: MySqlColumn<{
				name: "name";
				tableName: string;
				dataType: "string";
				columnType: "MySqlVarChar";
				data: string;
				driverParam: string | number;
				notNull: true;
				hasDefault: false;
				isPrimaryKey: false;
				isAutoincrement: false;
				hasRuntimeDefault: false;
				enumValues: [
					string,
					...string[]
				];
				baseColumn: never;
				generated: undefined;
			}, object>;
		};
		dialect: "mysql";
	}>;
	groupTagTableFactory: (name: string, id: () => MySqlIntBuilderInitial<any>, groupColReference: () => MySqlColumn) => import("drizzle-orm/mysql-core").MySqlTableWithColumns<{
		name: string;
		schema: undefined;
		columns: {
			id: MySqlColumn<{
				name: any;
				tableName: string;
				dataType: "number";
				columnType: "MySqlInt";
				data: number;
				driverParam: string | number;
				notNull: false;
				hasDefault: false;
				isPrimaryKey: false;
				isAutoincrement: false;
				hasRuntimeDefault: false;
				enumValues: undefined;
				baseColumn: never;
				generated: undefined;
			}, object>;
			name: MySqlColumn<{
				name: "name";
				tableName: string;
				dataType: "string";
				columnType: "MySqlVarChar";
				data: string;
				driverParam: string | number;
				notNull: true;
				hasDefault: false;
				isPrimaryKey: false;
				isAutoincrement: false;
				hasRuntimeDefault: false;
				enumValues: [
					string,
					...string[]
				];
				baseColumn: never;
				generated: undefined;
			}, object>;
			groupId: MySqlColumn<{
				name: "groupId";
				tableName: string;
				dataType: "number";
				columnType: "MySqlInt";
				data: number;
				driverParam: string | number;
				notNull: false;
				hasDefault: false;
				isPrimaryKey: false;
				isAutoincrement: false;
				hasRuntimeDefault: false;
				enumValues: undefined;
				baseColumn: never;
				generated: undefined;
			}, object>;
		};
		dialect: "mysql";
	}>;
	tagCols: (id: () => MySqlIntBuilderInitial<any>) => {
		id: MySqlIntBuilderInitial<any>;
		name: import("drizzle-orm").NotNull<import("drizzle-orm/mysql-core").MySqlVarCharBuilderInitial<"name", [
			string,
			...string[]
		]>>;
	};
	groupTagCols: (id: () => MySqlIntBuilderInitial<any>, groupColReference: () => MySqlColumn) => {
		id: MySqlIntBuilderInitial<any>;
		name: import("drizzle-orm").NotNull<import("drizzle-orm/mysql-core").MySqlVarCharBuilderInitial<"name", [
			string,
			...string[]
		]>>;
		groupId: MySqlIntBuilderInitial<"groupId">;
	};
};
export type ZodLike = {
	parse: (arg: any) => {
		success: boolean;
		data: any;
		error: {
			issues: any;
		};
	};
};
export declare function validatorPlugin(upsert: ZodLike): (repository: EntityRepositoryInterface) => void;
export declare function validatorPlugin(insert: ZodLike, update?: ZodLike): (repository: EntityRepositoryInterface) => void;

export {
	Storage$1 as Storage,
};

export {};
