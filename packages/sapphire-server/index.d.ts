// Generated by dts-bundle-generator v9.5.1

import { Buffer } from 'buffer';
import { InferSelectModel, SQL, SQLWrapper } from 'drizzle-orm';
import { AnyMySqlSelectQueryBuilder, MySqlColumn, MySqlSelectWithout, MySqlTable, MySqlTableWithColumns, MySqlView } from 'drizzle-orm/mysql-core';
import { MySql2Database } from 'drizzle-orm/mysql2';

export type ErrorData = {
	message?: string;
	details?: Record<string, any>;
	httpResponseCode: number;
	silent: boolean;
};
export type MaybeArray<TYPE> = TYPE | Array<TYPE>;
export type MaybeUnset<TYPE> = TYPE | null | undefined;
export declare const sapphireError: {
	notFound: (details?: Record<string, any>) => ErrorData;
	unauthorized: () => ErrorData;
	forbidden: () => ErrorData;
	collectionNotExist: (name: string) => ErrorData;
	fileNotProvided: () => ErrorData;
};
export type MaybeUndefined<TYPE> = TYPE | undefined;
export type MaybeNull<TYPE> = TYPE | null;
type MaybeUnset$1<TYPE> = TYPE | null | undefined;
export type NumericString = `${number}`;
/**
 * A constructor type.
 * @template OBJECT_TYPE - The type of the object.
 */
export type T_Constructor<OBJECT_TYPE> = (new (...args: any[]) => OBJECT_TYPE);
/**
 * A class type.
 * @template OBJECT_TYPE - The type of the object.
 * @template CLASS - The type of the class.
 */
export type T_Class<OBJECT_TYPE, CLASS> = T_Constructor<OBJECT_TYPE> & CLASS;
export type NonFunctionKeys<VALUES extends Record<string, any>> = {
	[P in keyof VALUES]: VALUES[P] extends (...args: any[]) => any ? never : P;
}[keyof VALUES];
export type ExcludeFunctions<VALUES extends Record<string, any>> = Partial<Pick<VALUES, NonFunctionKeys<VALUES>>>;
export type FileSizeWithUnit = `${number}KB` | `${number}kb` | `${number}kB` | `${number}MB` | `${number}mb` | `${number}GB` | `${number}gb` | `${number}TB` | `${number}tb` | `${number}B` | `${number}b` | `${number}` | number;
export type State<T = {}> = Record<string, any> & T;
/**
 * Represents an interface for a block in a process pipeline.
 * @template OPTIONS - The type of options for the block.
 */
export interface Block<OPTIONS extends string> {
	/**
	 * Prepends a segment to the block.
	 * @param {Function} segment - The segment function to prepend.
	 * @returns The updated block runner instance.
	 */
	prepend: (segment: Function) => Record<OPTIONS, BlockRunner<OPTIONS>>;
	/**
	 * Appends a segment to the block.
	 * @param {Function} segment - The segment function to append.
	 * @returns The updated block runner instance.
	 */
	append: (segment: Function) => Record<OPTIONS, BlockRunner<OPTIONS>>;
}
declare class BlockRunner<OPTIONS extends string> implements Block<OPTIONS> {
	#private;
	readonly pipeline: ProcessPipeline<OPTIONS>;
	constructor(pipeline: ProcessPipeline<OPTIONS>);
	/**
	 * Runs the block runner by executing segments in the specified order.
	 * @param {object | undefined} ctx - The context object.
	 * @param {State} state - The state object to pass through the block runner.
	 * @returns {Promise<void>} A promise that resolves after executing all segments.
	 */
	run(ctx: object | undefined, state: State): Promise<void>;
	/**
	 * Prepends a segment to the block runner.
	 * @param {Function} segment - The segment function to prepend.
	 * @returns {Record<OPTIONS, BlockRunner<OPTIONS>>} The updated block runner instance.
	 */
	prepend(segment: Function): Record<OPTIONS, BlockRunner<OPTIONS>>;
	/**
	 * Appends a segment to the block runner.
	 * @param {Function} segment - The segment function to append.
	 * @returns {Record<OPTIONS, BlockRunner<OPTIONS>>} The updated block runner instance.
	 */
	append(segment: Function): Record<OPTIONS, BlockRunner<OPTIONS>>;
}
declare class ProcessPipeline<OPTIONS extends string = string> {
	#private;
	private readonly names;
	/**
	 * Accessible blocks of the process pipeline.
	 * @type {Record<OPTIONS, Block<OPTIONS>>}
	 */
	readonly blocks: Record<OPTIONS, Block<OPTIONS>>;
	/**
	 * Initializes the ProcessPipeline with the provided names.
	 * @param {...OPTIONS} names - The names of the blocks in the process pipeline.
	 */
	constructor(...names: OPTIONS[]);
	/**
	 * Runs the process pipeline by executing blocks in the specified order.
	 * @param {object | undefined} ctx - The context object.
	 * @param {Record<string, any>} state - The state object to pass through the pipeline.
	 * @returns {Promise<Record<string, any>>} A promise that resolves to the final state after executing all blocks.
	 */
	run(ctx: object | undefined, state: Record<string, any>): Promise<Record<string, any>>;
	/**
	 * Sets up the process pipeline blocks with the provided functions.
	 * @param {Partial<Record<OPTIONS, [Function] | Function>>} blocks - The functions to set up for each block.
	 * @returns {this} The updated ProcessPipeline instance.
	 */
	setup(blocks: Partial<Record<OPTIONS, [
		Function
	] | Function>>): this;
}
export type WithIdOptional<TYPE = {}> = {
	id: MaybeNull<number>;
} & TYPE;
/**
 * The data transfer object type.
 * @template SCHEMA - The type of the database schema representing the entity's view.
 */
export type Dto<SCHEMA extends MySqlTable> = WithIdOptional<InferSelectModel<SCHEMA>>;
export type ViewDto<SCHEMA extends MySqlTable | MySqlView<any, any, any>> = WithIdOptional<SCHEMA extends MySqlTable ? InferSelectModel<SCHEMA> : MySqlView<any, any, any>>;
declare abstract class ViewEntity {
	static repository: ViewEntityRepositoryInterface;
	get $repository(): ViewEntityRepositoryInterface<any, any, any, any>;
	id: MaybeNull<number>;
	get $id(): number;
	constructor();
	private static get exportFields();
	/**
	 * Exports the entity to a plain object for exporting.
	 * @returns A plain object representation of the entity.
	 */
	$export(): Record<string, any>;
	/**
	 * Picks specified fields from export.
	 * @param fields
	 */
	$pick(...fields: string[]): Record<string, any>;
	/**
	 * Omits specified fields from export.
	 * @param fields
	 */
	$omit(...fields: string[]): Record<string, any>;
	/**
	 * Returns a JSON representation of the entity.
	 * @returns A JSON representation of the entity.
	 */
	toJSON(): Record<string, any>;
	/**
	 * Returns a string representation of the entity.
	 * @returns A string representation of the entity.
	 */
	toString(): string;
}
export interface ViewEntityRepositoryInterface<SCHEMA extends MySqlTable<any> | MySqlView<any, any, any> = any, ITEM extends ViewEntity = any, ENTITY extends T_Class<ITEM, typeof ViewEntity> = any, DTO extends ViewDto<SCHEMA> = any> {
	readonly db: MySql2Database<any>;
	readonly schema: SCHEMA;
	readonly entity: ENTITY;
	fields: string[];
	pipelines: {
		getAll: ProcessPipeline<"prepare" | "action" | "finalize">;
		getOne: ProcessPipeline<"prepare" | "action" | "finalize">;
		getArray: ProcessPipeline<"prepare" | "action" | "finalize">;
	};
	instantiate: {
		all: (dtoSet: Array<DTO>) => Promise<Array<ITEM>>;
		one: (dto: (DTO | undefined)) => Promise<undefined | ITEM>;
		first: (dtoSet: Array<DTO>) => Promise<MaybeUndefined<ITEM>>;
	};
	addPlugin(plugin: (repository: ViewEntityRepositoryInterface) => any): this;
	getRawDTO(id: MaybeUnset$1<number>): Promise<MaybeUndefined<DTO>>;
	get(): Promise<Array<ITEM>>;
	get(ids: Array<number>): Promise<Array<ITEM>>;
	get(id: MaybeUnset$1<number>): Promise<ITEM | undefined>;
	create(): Promise<ITEM>;
	reload(item: any): Promise<void>;
}
export interface EntityRepositoryInterface<SCHEMA extends MySqlTableWithColumns<any> = any, ITEM extends Entity = any, ENTITY extends T_Class<ITEM, typeof Entity> = any, DTO extends Dto<SCHEMA> = any> extends ViewEntityRepositoryInterface<SCHEMA, ITEM, ENTITY> {
	pipelines: {
		getAll: ProcessPipeline<"prepare" | "action" | "finalize">;
		getOne: ProcessPipeline<"prepare" | "action" | "finalize">;
		getArray: ProcessPipeline<"prepare" | "action" | "finalize">;
		insert: ProcessPipeline<"prepare" | "action" | "finalize">;
		update: ProcessPipeline<"prepare" | "action" | "finalize">;
		delete: ProcessPipeline<"prepare" | "action" | "finalize">;
		overwrite: ProcessPipeline<"prepare" | "action" | "finalize">;
	};
	instantiate: {
		all: (dtoSet: Array<DTO>) => Promise<Array<ITEM>>;
		one: (dto: (DTO | undefined)) => Promise<undefined | ITEM>;
		first: (dtoSet: Array<DTO>) => Promise<MaybeUndefined<ITEM>>;
	};
	addPlugin(plugin: (repository: EntityRepositoryInterface) => any): this;
	save(item: ITEM | undefined): Promise<any>;
	update(item: ITEM | undefined): Promise<any>;
	insert(item: ITEM | undefined): Promise<any>;
	overwrite(item: ITEM | undefined, values: Record<string, any>, reload?: boolean): Promise<any>;
	delete(item: ITEM | undefined): Promise<any>;
	create(importData?: Dto<MySqlTable>): Promise<ITEM>;
}
declare abstract class Entity extends ViewEntity {
	static repository: EntityRepositoryInterface;
	get $repository(): EntityRepositoryInterface<any, any, any, any>;
	private static get importFields();
	/**
	 * Imports data into the entity.
	 * @param importData record of the properties to copy onto the entity.
	 * @param onlyDecoratedProperties the properties doesn't have to be decorated if this is false (default true)
	 */
	$import<DATA extends {
		[P in keyof ExcludeFunctions<this>]: ExcludeFunctions<this>[P];
	}>(importData: DATA, onlyDecoratedProperties?: boolean): this;
	/**
	 * Saves the entity to the database.
	 * @param saveData: properties of Entity
	 * @param onlyDecoratedProperties sets if @Import decorator is required or not for the properties you save this way, false by default
	 */
	$save<DATA extends {
		[P in keyof ExcludeFunctions<this>]: ExcludeFunctions<this>[P];
	}>(saveData?: DATA, onlyDecoratedProperties?: boolean): Promise<any>;
	/**
	 * Deletes the entity from the database.
	 */
	$delete(): Promise<any>;
	/**
	 * Overwrites the entity with the provided data, without validation.
	 * @param data
	 */
	$overwrite<KEY extends keyof this>(data: Record<KEY, typeof Entity[KEY]>): Promise<any>;
}
export type AttachmentObject = {
	name: string;
	size: number;
	id: string;
	metadata: Record<string, any>;
};
export type AttachmentObjects = Array<AttachmentObject>;
export type ITmpFile = {
	file: string;
	filename: string;
	release: () => void | Promise<void>;
};
export type CollectionOptions = {
	limit?: {
		size?: number | NumericString | FileSizeWithUnit;
		count?: number | NumericString;
	};
	mime?: string | Array<string>;
	ext?: string | Array<string>;
};
export type Rules = {
	limit: {
		size: number;
		count: number;
	};
	mime: undefined | Array<string>;
	ext: undefined | Array<string>;
};
export type KeyValue<T> = {
	key: string | number;
	value: T;
};
declare abstract class Cache$1<T = any> {
	protected ttl: number;
	protected prefix?: string | undefined;
	protected constructor(ttl: number, prefix?: string | undefined);
	/**
	 * Returns a function that reads a cached item if available; otherwise, retrieves it using the provided handler and caches it.
	 * @param ttl - Optional time-to-live value for the cached item.
	 * @returns A function that reads and caches items.
	 */
	getReader(ttl?: number): (handler: () => any, key: string | number, ttl?: number) => Promise<any>;
	/**
	 * Returns a function that deletes an item from the cache by key.
	 * @returns A function that deletes items from the cache.
	 */
	getInvalidator(): (key: string | number) => Promise<void>;
	/**
	 * Reads a cached item by key or retrieves it using the provided handler and caches it.
	 * @param handler - The function to retrieve the item if not cached.
	 * @param key - The key of the item to read or retrieve.
	 * @param ttl - Optional time-to-live value for the cached item.
	 * @returns A Promise resolving to the retrieved item.
	 */
	read(handler: () => any, key: string | number, ttl?: number): Promise<any>;
	/**
	 * Generates a cache key based on the provided key(s) and prefix.
	 * @param keys - The key or array of keys to generate the cache key(s) from.
	 * @returns The generated cache key(s).
	 */
	key(keys: Array<string | number>): Array<string>;
	key(key: string | number): string;
	key(key: string | number | Array<string | number>): string | Array<string>;
	/**
	 * Abstract method to set item(s) in the cache with an optional TTL.
	 * @param item - The key-value pair or array of key-value pairs to set in the cache.
	 * @param ttl - Optional time-to-live value for the cached item(s).
	 * @returns A Promise indicating the success of the operation.
	 */
	abstract set(item: KeyValue<T>, ttl?: number): Promise<void>;
	abstract set(items: Array<KeyValue<T>>, ttl?: number): Promise<void>;
	/**
	 * Abstract method to get a cached item by key.
	 * @param key - The key of the item to retrieve from the cache.
	 * @returns A Promise resolving to the cached item or undefined.
	 */
	abstract get(key: string | number): Promise<T | undefined>;
	abstract get(keys: Array<string | number>): Promise<Array<T>>;
	/**
	 * Abstract method to delete an item from the cache by key.
	 * @param key - The key of the item to delete from the cache.
	 * @returns A Promise indicating the success of the operation.
	 */
	abstract del(key: string | number): Promise<void>;
	abstract del(keys: Array<string | number>): Promise<void>;
	/**
	 * Abstract method to clear all items from the cache.
	 * @returns A Promise indicating the success of the operation.
	 */
	abstract clear(): Promise<void>;
}
export type GroupDefinition = {
	storage: Storage$1;
	group: string;
	entityRepository: EntityRepositoryInterface;
};
export type Collections = Record<string, Collection>;
declare class Storage$1 {
	readonly path: string;
	readonly db: MySql2Database<any>;
	readonly schema: MySqlTable;
	readonly cache?: Cache$1 | undefined;
	readonly cleanup?: ((name: string, id: number, file: string) => Promise<void>) | undefined;
	constructor(path: string, db: MySql2Database<any>, schema: MySqlTable, cache?: Cache$1 | undefined, cleanup?: ((name: string, id: number, file: string) => Promise<void>) | undefined);
	collections: Collections;
	groups: Record<string, {
		collections: Collections;
		repository: EntityRepositoryInterface;
	}>;
	/**
	 * Add a collection to the storage
	 * @param collection
	 */
	addCollection(collection: any): void;
	/**
	 * Get a collection from the storage
	 * @param name
	 * @param entityRepository
	 */
	getGroupDefinition(name: string, entityRepository: EntityRepositoryInterface): GroupDefinition;
	private get stmt_get();
	private get stmt_all();
	private get stmt_del();
	getPath(name: string, id: number): string;
	protected getCacheKey(name: string, id: number): string;
	/**
	 * Get all attachments for a given name and id
	 * @param name
	 * @param id
	 * @param res
	 */
	get(name: string, id: number, res?: {
		found?: "db" | "cache" | false;
	}): Promise<AttachmentObjects>;
	protected getIndexOfAttachments(name: string, id: number, filename: string, fail?: boolean): Promise<{
		attachments: AttachmentObjects;
		index: number;
	}>;
	/**
	 * Delete all attachments for a given id
	 * @param repository
	 * @param id
	 */
	destroy(repository: EntityRepositoryInterface, id: number): Promise<void>;
	protected destroyFiles(name: string, id: number): Promise<void>;
	protected updateRecord(name: string, id: number, attachments: AttachmentObjects): Promise<void>;
	/**
	 * Add an attachment to the storage
	 * @param name
	 * @param id
	 * @param file
	 * @param metadata
	 */
	add(name: string, id: number, file: ITmpFile, metadata: Record<string, any>): Promise<void>;
	/**
	 * Delete an attachment from the storage
	 * @param name
	 * @param id
	 * @param filename
	 */
	delete(name: string, id: number, filename: string): Promise<void>;
	/**
	 * Set the position of an attachment
	 * @param name
	 * @param id
	 * @param filename
	 * @param position
	 */
	setPosition(name: string, id: number, filename: string, position: number): Promise<void>;
	/**
	 * Update the metadata of an attachment
	 * @param name
	 * @param id
	 * @param filename
	 * @param metadata
	 */
	updateMetadata(name: string, id: number, filename: string, metadata: Record<string, any>): Promise<void>;
	/**
	 * Rename an attachment
	 * @param name
	 * @param id
	 * @param filename
	 * @param newName
	 */
	rename(name: string, id: number, filename: string, newName: string): Promise<void>;
	plugin(): (repository: EntityRepositoryInterface) => void;
}
declare class CollectionHandler<METADATA extends Record<string, any>> extends Array<Attachment<METADATA>> {
	#private;
	protected loaded: boolean;
	/**
	 * Get the entity owning the collection
	 */
	get entity(): WithIdOptional<Record<string, any>>;
	/**
	 * Get the id of the entity owning the collection
	 */
	get id(): number;
	/**
	 * Get the collection
	 */
	get collection(): Collection<METADATA>;
	/**
	 * Get the storage of the collection
	 */
	get storage(): Storage$1;
	constructor(collection: Collection<METADATA>, entity: WithIdOptional<Record<string, any>>);
	push(...args: any[]): never;
	unshift(...args: any[]): never;
	pop(): never;
	shift(): never;
	/**
	 * Load the collection
	 */
	load(): Promise<this>;
	/**
	 * Add a file to the collection
	 * @param file
	 */
	add(file: ITmpFile): Promise<void>;
	toJSON(): {
		collection: string;
		id: number;
		files: Array<{
			metadata: Record<string, any>;
			name: string;
			id: string;
			size: number;
		}> | null;
		rules: Record<string, any>;
	};
	/**
	 * Get the first file in the collection
	 */
	first(): Attachment<METADATA> | undefined;
	/**
	 * Get the last file in the collection
	 */
	last(): Attachment<METADATA> | undefined;
	/**
	 * Get a file by name
	 * @param filename
	 */
	findFile(filename: string): Attachment<METADATA> | undefined;
	/**
	 * Get files by a glob pattern
	 * @param glob
	 */
	findFiles(glob: string): Array<Attachment<METADATA>>;
}
declare abstract class Collection<METADATA extends Record<string, any> = {}> {
	readonly name: string;
	readonly groupDefinition: {
		storage: Storage$1;
		group: string;
		entityRepository: EntityRepositoryInterface;
	};
	readonly entityRepository: EntityRepositoryInterface;
	readonly group: string;
	private readonly _storage;
	/**
	 * The storage of the collection
	 */
	get storage(): Storage$1;
	getPath(entityId: number): string;
	/**
	 * The rules for the collection
	 */
	readonly rules: Rules;
	constructor(name: string, groupDefinition: {
		storage: Storage$1;
		group: string;
		entityRepository: EntityRepositoryInterface;
	}, rules: CollectionOptions);
	/**
	 * Get a collection handler
	 * @param entity
	 */
	handler(entity: WithIdOptional<Record<string, any>>): CollectionHandler<METADATA> | undefined;
	protected updateMetadata(id: number, filename: string, metadata: Partial<METADATA>): Promise<void>;
	protected prepareFile(file: ITmpFile): Promise<{
		file: ITmpFile;
		metadata: Record<string, any>;
	}>;
	/**
	 * Prepare the file for storage
	 * @param collectionHandler
	 * @param file
	 */
	prepare(collectionHandler: CollectionHandler<METADATA>, file: ITmpFile): Promise<{
		file: ITmpFile;
		metadata: Record<string, any>;
	}>;
	/**
	 * Hook for when an attachment is removed
	 */
	onDelete(): Promise<void>;
	/**
	 * Hook for when an attachment is modified
	 */
	onModify(): Promise<void>;
	/**
	 * Get attachments for an entity
	 * @param id
	 */
	get(id: number): Promise<Array<Attachment<METADATA>>>;
}
declare class Attachment<METADATA extends Record<string, any>> implements AttachmentObject {
	#private;
	/**
	 * The metadata of the attachment
	 */
	get metadata(): METADATA;
	/**
	 * The file size of the attachment
	 */
	get size(): number;
	/**
	 * The id of the attachment
	 */
	get id(): string;
	/**
	 * The filename of the attachment
	 */
	get name(): string;
	/**
	 * The collection of the attachment
	 */
	get collection(): Collection<METADATA>;
	/**
	 * The entity id of the attachment
	 */
	get entityId(): number;
	/**
	 * returns the path to the attachment
	 * */
	get path(): string;
	base64(): Promise<string>;
	dataUrl(): Promise<string>;
	constructor(attachmentObject: AttachmentObject, collection: Collection<METADATA>, entityId: number);
	toJSON(): {
		metadata: METADATA;
		name: string;
		id: string;
		size: number;
	};
	/**
	 * Save the metadata of the attachment
	 */
	saveMetaData(): Promise<void>;
	/**
	 * Set the position of the attachment
	 * @param position
	 */
	setPositions(position: number): Promise<void>;
	/**
	 * Delete the attachment
	 */
	delete(): Promise<void>;
	/**
	 * Rename the attachment
	 * @param name
	 */
	rename(name: string): Promise<void>;
}
export declare class ItemAdapter<SCHEMA extends MySqlTableWithColumns<any>, ITEM extends Entity, DTO extends Dto<SCHEMA> = Dto<SCHEMA>> {
	readonly schema: SCHEMA;
	readonly repository: EntityRepositoryInterface;
	protected type: string;
	constructor(schema: SCHEMA, repository: EntityRepositoryInterface);
	/**
	 * API method
	 *
	 * @param id
	 * @param preset
	 * @param env
	 */
	get(id: number | null, preset: undefined | Record<string, any>, env: Record<string, any>): Promise<{
		data: Partial<DTO>;
		type: any;
	}>;
	/**
	 * API method
	 *
	 * @param id
	 * @param values
	 * @param env
	 */
	save(id: number | null, values: Record<string, any> | undefined, env: Record<string, any>): Promise<MaybeUnset<number>>;
	/**
	 * API method
	 *
	 * @param id
	 * @param env
	 */
	delete(id: number, env: Record<string, any>): Promise<boolean>;
	/**
	 * You can process the incoming data here if you need to modify it.
	 * By default, it handles date type fields.
	 *
	 * @param id
	 * @param values
	 * @param env
	 * @protected
	 */
	protected import(id: number | null, values: Record<string, any>, env: Record<string, any>): Promise<Record<string, any>>;
	/**
	 * In this method, you can finalize how you want to represent an Item towards the frontend.
	 *
	 * @param item
	 * @param preset
	 * @param env
	 * @protected
	 */
	protected export(item: ITEM, preset: undefined | Record<string, any>, env: Record<string, any>): Promise<{
		data: Partial<DTO>;
		type: any;
	}>;
	/**
	 * In this method, you can define how a newly created element should look for the frontend.
	 *
	 * @param preset
	 * @param env
	 * @protected
	 */
	protected new(preset: undefined | Record<string, any>, env: Record<string, any>): Promise<{
		type: string;
		data: Partial<DTO> & Record<string, any>;
	}>;
}
export type Order = {
	by: MySqlColumn;
	reverse: boolean | undefined;
};
export type Orders = Record<string, Array<Order>>;
export type Search = SQLWrapper | SQL | undefined;
export type BaseSelect<A extends AnyMySqlSelectQueryBuilder = any, B extends boolean = any, C extends keyof A & string = any> = MySqlSelectWithout<A, B, C>;
export declare class JoinedQuickSearch<T extends MySqlTableWithColumns<any> = any> {
	readonly table: T;
	readonly field: MaybeArray<keyof T>;
	readonly connection: SQL;
	constructor(table: T, field: MaybeArray<keyof T>, connection: SQL);
}
export declare class ListAdapter<SCHEMA extends MySqlTableWithColumns<any> = any> {
	protected schema: SCHEMA;
	protected db: MySql2Database<any>;
	protected quickSearchFields: MaybeArray<MySqlColumn | JoinedQuickSearch> | undefined;
	protected sorting: Orders;
	constructor(schema: SCHEMA, db: MySql2Database<any>, quickSearchFields: MaybeArray<MySqlColumn | JoinedQuickSearch> | undefined, sorting?: Orders);
	/**
	 * API method
	 *
	 * @param page
	 * @param pageSize
	 * @param quickSearch
	 * @param order
	 * @param search
	 * @param env
	 */
	get(page: number, pageSize: number, quickSearch?: string, order?: string, search?: Record<string, any>, env?: Record<string, any>): Promise<{
		items: {
			data: any;
			type: SCHEMA["_"]["name"];
		}[];
		page: number;
		count: number;
	}>;
	/**
	 * In this method, you can finalize how you want to represent an Item towards the frontend.
	 * @param item
	 * @protected
	 */
	protected export(item: any): any;
	/**
	 * Although you can specify the possible sorting options for your list in the constructor,
	 * you can also implement them here for more complex cases.
	 *
	 * @protected
	 */
	protected get orders(): Orders;
	/**
	 * The filter method will run for each query, and you can build basic filters into it.
	 * It receives the environmental variables as parameters.
	 *
	 * @param env
	 * @protected
	 */
	protected filter(env: Record<string, any> | undefined): Promise<Search>;
	/**
	 * This method implements the custom search. If you need a custom search, override this method.
	 * It receives the environmental variables and search parameters as arguments.
	 *
	 * @param search
	 * @param env
	 * @protected
	 */
	protected search(search: Record<string, any> | undefined, env: Record<string, any> | undefined): Promise<Search>;
	/**
	 * This method implements the quick search. In most cases, you don’t need to override it!
	 * @param search
	 * @protected
	 */
	protected quickSearch(search?: string): Promise<Search>;
	protected orderBy(base: BaseSelect, name: string | undefined): BaseSelect;
	private select;
	private joinQuickSearch;
	private pagination;
	private where;
	private calcPageIndex;
	private count;
}
declare class TmpFile {
	file: string;
	get filename(): string;
	constructor(file: string);
	release(): Promise<void>;
}
declare class TmpFileCreator {
	private path;
	constructor(path: string);
	get targetDir(): Promise<string>;
	createFromFile(file: File, removeOriginal?: boolean): Promise<TmpFile>;
	createFromBuffer(filename: string, buffer: Buffer): Promise<TmpFile>;
	createFromFilePath(file: string, removeOriginal?: boolean): Promise<TmpFile>;
}
export declare class StorageAdapter<SCHEMA extends MySqlTableWithColumns<any>> {
	schema: SCHEMA;
	protected repository: EntityRepositoryInterface;
	protected storage: Storage$1;
	readonly tmpFileFactory: TmpFileCreator;
	protected allowedCollections?: string[] | undefined;
	protected type: string;
	constructor(schema: SCHEMA, repository: EntityRepositoryInterface, storage: Storage$1, tmpFileFactory: TmpFileCreator, allowedCollections?: string[] | undefined);
	/**
	 * API method
	 *
	 * @param id
	 * @param env
	 */
	get(id: number, env: Record<string, any>): Promise<{
		id: number;
		collection: string;
		files: Attachment<{}>[];
		rules: Rules;
	}[]>;
	/**
	 * API method
	 *
	 * @param id
	 * @param collectionName
	 * @param files
	 */
	upload(id: number, collectionName: string, files: Array<TmpFile>): Promise<boolean>;
	/**
	 * API method
	 *
	 * @param id
	 * @param collectionName
	 * @param fileName
	 */
	delete(id: number, collectionName: string, fileName: string): Promise<boolean>;
	/**
	 * API method
	 *
	 * @param id
	 * @param collectionName
	 * @param fileName
	 * @param newMetaData
	 * @param newName
	 */
	updateFileData(id: number, collectionName: string, fileName: string, newMetaData?: Record<string, any>, newName?: string): Promise<boolean>;
	/**
	 * API method
	 *
	 * @param id
	 * @param collectionName
	 * @param fileName
	 * @param position
	 */
	changeFilePosition(id: number, collectionName: string, fileName: string, position: number): Promise<boolean>;
	/**
	 * Although you can specify the list of allowed collections in the constructor, you can also implement them here for more complex cases.
	 *
	 * @param env
	 * @protected
	 */
	protected getAllowedCollections(env: Record<string, any>): undefined | string[];
	protected findFile(id: number, collectionName: string, fileName: string): Promise<Attachment<any>>;
}
export declare class SapphireApi {
	protected readonly itemAdapter?: ItemAdapter<any, any> | undefined;
	protected readonly listAdapter?: ListAdapter | undefined;
	protected readonly storageAdapter?: StorageAdapter<any> | undefined;
	constructor(itemAdapter?: ItemAdapter<any, any> | undefined, listAdapter?: ListAdapter | undefined, storageAdapter?: StorageAdapter<any> | undefined);
	list_get(args: {
		page: number;
		pageSize: number;
		quickSearch?: string;
		order?: string;
		search?: Record<string, any>;
	}, env: any): Promise<{
		count: number;
		page: number;
		items: any[];
	}> | never;
	item_get(args: {
		id: string | null;
		preset?: Record<string, any>;
	}, env: any): Promise<{
		data: Partial<Dto<any>> | undefined;
		type: any;
	}> | never;
	item_save(args: {
		id: number | null;
		values: Record<string, any>;
	}, env: any): Promise<MaybeUnset<number>> | never;
	item_delete(args: {
		id: number;
	}, env: any): Promise<boolean> | never;
	attachment_get(args: {
		id: string;
	}, env: any): Promise<any[]> | never;
	attachment_upload(args: {
		id: string;
		collectionName: string;
	}, { files }: {
		files: Array<File>;
	}, env: any): Promise<boolean> | never;
	attachment_delete(args: {
		id: string;
		collectionName: string;
		fileName: string;
	}, env: any): Promise<boolean> | never;
	attachment_updateFileData(args: {
		id: string;
		collectionName: string;
		fileName: string;
		newMetaData?: Record<string, any>;
		newName?: string;
	}, env: any): Promise<boolean> | never;
	attachment_changeFilePosition(args: {
		id: string;
		collectionName: string;
		fileName: string;
		position: string;
	}, env: any): Promise<boolean> | never;
}

export {};
